Key,rule,Message,name,mdDesc,severity,remFnBaseEffort,cleanCodeAttribute,cleanCodeAttributeCategory,impacts,securityStandards
AZHFJ8MWTlwiQl6exCX5,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCX6,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCXa,c:S859,cast from 'const struct xgmac_dma_chnl_config *' to 'struct xgmac_dma_chnl_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXb,c:S859,cast from 'volatile struct xgmac_dma_tx_desc_meta *' to 'struct xgmac_dma_tx_desc_meta *' drops volatile qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXc,c:S859,cast from 'volatile struct xgmac_dma_rx_desc_meta *' to 'struct xgmac_dma_rx_desc_meta *' drops volatile qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCX8,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""dma_chnl_cfg"" is ""struct xgmac_dma_chnl_config *const"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCXd,c:S859,cast from 'const struct xgmac_dma_chnl_config *' to 'struct xgmac_dma_chnl_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCX7,c:S5955,"Declare the variable ""dma_chnl"" inside the loop.",Loop variables should be declared in the minimal possible scope,"<h2>Why is this an issue?</h2>
<p>When a loop variable is not used outside of a loop, it should be declared inside the loop declaration:</p>
<ul>
  <li> It improves readability. The scope of the variable is clearly defined. </li>
  <li> It reduces the number of mistakes. The variable can’t be accidentally misused outside of the loop. </li>
  <li> Resources are not retained longer than necessary. </li>
</ul>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void f() {
  int i = 0; // Noncompliant: i is not used outside of the loop
  for (i = 0; i &lt; 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; std::endl;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void f() {
  for (int i = 0; i &lt; 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; std::endl;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es5-keep-scopes-small"">ES.5: Keep
  scopes small</a> </li>
</ul>",MINOR,5min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCXe,c:S859,cast from 'volatile struct xgmac_dma_tx_desc_meta *' to 'struct xgmac_dma_tx_desc_meta *' drops volatile qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXf,c:S859,cast from 'volatile struct xgmac_dma_rx_desc_meta *' to 'struct xgmac_dma_rx_desc_meta *' drops volatile qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXg,c:S859,cast from 'const struct xgmac_mtl_config *' to 'struct xgmac_mtl_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCX9,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCX-,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCX_,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""addr"" is ""unsigned char *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYA,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""data"" is ""struct eth_dwc_xgmac_dev_data *const"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCXh,c:S859,cast from 'const struct xgmac_mac_config *' to 'struct xgmac_mac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYB,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""mac_cfg"" is ""struct xgmac_mac_config *const"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYC,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYD,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYE,c:S3776,Refactor this function to reduce its Cognitive Complexity from 33 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXi,c:S859,cast from 'const void *' to 'struct eth_dwc_xgmac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXj,c:S859,cast from 'const struct xgmac_dma_chnl_config *' to 'struct xgmac_dma_chnl_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXk,c:S859,cast from 'volatile struct xgmac_dma_rx_desc_meta *' to 'struct xgmac_dma_rx_desc_meta *' drops volatile qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYI,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYG,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYH,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYJ,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYK,c:S1110,Remove these redundant parentheses.,Redundant pairs of parentheses should be removed,"<h2>Why is this an issue?</h2>
<p>Parentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.</p>
<pre>
a = (b * c) + (d * e); // Compliant: the intent is clear.
</pre>
<p>Redundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify
the code. They should be removed.</p>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int x = ((y / 2 + 1)); // Noncompliant

if (a &amp;&amp; ((x + y &gt; 0))) { // Noncompliant
  return ((x + 1)); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int x = (y / 2 + 1);

if (a &amp;&amp; (x + y &gt; 0)) {
  return (x + 1);
}
</pre>
<h3>Exceptions</h3>
<p>Assignments inside conditions are often the result of a mistake. {rule:c:S1121} flags this potential bug.</p>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
if (x = 7) { // Noncompliant: Did the author mean ""x == 7""?
  // ...
}
</pre>
<p>Adding a pair of parentheses to clearly state the intent is standard practice and is accepted by this rule.</p>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
if ((x = 7)) { // Compliant
  // ...
}
</pre>",MAJOR,1min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8MXTlwiQl6exCYL,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYM,c:S1110,Remove these redundant parentheses.,Redundant pairs of parentheses should be removed,"<h2>Why is this an issue?</h2>
<p>Parentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.</p>
<pre>
a = (b * c) + (d * e); // Compliant: the intent is clear.
</pre>
<p>Redundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify
the code. They should be removed.</p>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int x = ((y / 2 + 1)); // Noncompliant

if (a &amp;&amp; ((x + y &gt; 0))) { // Noncompliant
  return ((x + 1)); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int x = (y / 2 + 1);

if (a &amp;&amp; (x + y &gt; 0)) {
  return (x + 1);
}
</pre>
<h3>Exceptions</h3>
<p>Assignments inside conditions are often the result of a mistake. {rule:c:S1121} flags this potential bug.</p>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
if (x = 7) { // Noncompliant: Did the author mean ""x == 7""?
  // ...
}
</pre>
<p>Adding a pair of parentheses to clearly state the intent is standard practice and is accepted by this rule.</p>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
if ((x = 7)) { // Compliant
  // ...
}
</pre>",MAJOR,1min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8MXTlwiQl6exCYF,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYN,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYO,c:S1110,Remove these redundant parentheses.,Redundant pairs of parentheses should be removed,"<h2>Why is this an issue?</h2>
<p>Parentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.</p>
<pre>
a = (b * c) + (d * e); // Compliant: the intent is clear.
</pre>
<p>Redundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify
the code. They should be removed.</p>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int x = ((y / 2 + 1)); // Noncompliant

if (a &amp;&amp; ((x + y &gt; 0))) { // Noncompliant
  return ((x + 1)); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int x = (y / 2 + 1);

if (a &amp;&amp; (x + y &gt; 0)) {
  return (x + 1);
}
</pre>
<h3>Exceptions</h3>
<p>Assignments inside conditions are often the result of a mistake. {rule:c:S1121} flags this potential bug.</p>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
if (x = 7) { // Noncompliant: Did the author mean ""x == 7""?
  // ...
}
</pre>
<p>Adding a pair of parentheses to clearly state the intent is standard practice and is accepted by this rule.</p>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
if ((x = 7)) { // Compliant
  // ...
}
</pre>",MAJOR,1min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8MWTlwiQl6exCXl,c:S859,cast from 'const void *' to 'struct eth_dwc_xgmac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYP,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""dma_chnl_cfg"" is ""struct xgmac_dma_chnl_config *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCXm,c:S859,cast from 'const struct xgmac_dma_chnl_config *' to 'struct xgmac_dma_chnl_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXn,c:S859,cast from 'volatile struct xgmac_dma_tx_desc_meta *' to 'struct xgmac_dma_tx_desc_meta *' drops volatile qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYQ,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYR,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYS,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCXo,c:S859,cast from 'const void *' to 'struct eth_dwc_xgmac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXp,c:S859,cast from 'const void *' to 'struct eth_dwc_xgmac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYT,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYU,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""dev_data"" is ""struct eth_dwc_xgmac_dev_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYV,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCXq,c:S859,cast from 'const void *' to 'struct eth_dwc_xgmac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYW,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""state"" is ""struct phy_link_state *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYX,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""user_data"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYY,c:S3458,"Remove this redundant ""case"" clause.","Empty ""case"" clauses that fall through to the ""default"" should be omitted","<h2>Why is this an issue?</h2>
<p>Empty <code>case</code> clauses that fall through to the default are useless. Whether or not such a <code>case</code> is present, the
<code>default</code> clause will be invoked. Such <code>case</code>s simply clutter the code, and should be removed.</p>
<h3>Noncompliant code example</h3>
<pre>
switch(ch)
{
  case 'a' :
    handleA();
    break;
  case 'b' :
    handleB();
    break;
  case 'c' :  // Noncompliant
  default:
    handleTheRest();
    break;
}
</pre>
<h3>Compliant solution</h3>
<pre>
switch(ch)
{
  case 'a' :
    handleA();
    break;
  case 'b' :
    handleB();
    break;
  default:
    handleTheRest();
    break;
}
</pre>",MINOR,1min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCXr,c:S859,cast from 'const void *' to 'struct eth_dwc_xgmac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXs,c:S859,cast from 'const struct xgmac_dma_chnl_config *' to 'struct xgmac_dma_chnl_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXt,c:S859,cast from 'volatile struct xgmac_dma_tx_desc_meta *' to 'struct xgmac_dma_tx_desc_meta *' drops volatile qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXu,c:S859,cast from 'volatile struct xgmac_dma_rx_desc_meta *' to 'struct xgmac_dma_rx_desc_meta *' drops volatile qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYZ,c:S924,"Reduce the number of nested ""break"" statements from 2 to 1 authorized.","Loops should not have more than one ""break"" or ""goto"" statement","<h2>Why is this an issue?</h2>
<p>Restricting the number of exits from a loop is done in the interests of good structured programming. One <code>break</code> or <code>goto</code>
statement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.</p>
<h3>Noncompliant code example</h3>
<p>With the default threshold of 1:</p>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
  else if (...) {
    break;      //  Non-compliant - second jump from loop
  }
  else {
    ...
  }
}
while (...) {
  if (...) {
    break;      // Compliant
  }
  if (...) {
    break;      // Non-compliant - second jump from loop
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
}
while (...) {
  if (...) {
    break;    // Compliant
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. </li>
  <li> MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. </li>
  <li> MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement </li>
</ul>",MAJOR,20min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8MXTlwiQl6exCYa,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYb,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCXv,c:S859,cast from 'const void *' to 'struct eth_dwc_xgmac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXw,c:S859,cast from 'const struct device *' to 'void *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXx,c:S859,cast from 'const void *' to 'struct eth_dwc_xgmac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCXy,c:S859,cast from 'const void *' to 'struct eth_dwc_xgmac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYc,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCXz,c:S859,cast from 'const void *' to 'struct eth_dwc_xgmac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCX0,c:S859,cast from 'const struct xgmac_dma_chnl_config *' to 'struct xgmac_dma_chnl_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYd,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MWTlwiQl6exCX1,c:S859,cast from 'volatile struct xgmac_dma_tx_desc_meta *' to 'struct xgmac_dma_tx_desc_meta *' drops volatile qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYe,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYf,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYg,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYh,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYi,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYj,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""addr"" is ""unsigned char *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8MXTlwiQl6exCYk,c:S3776,Refactor this function to reduce its Cognitive Complexity from 28 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCX2,c:S859,cast from 'const void *' to 'struct eth_dwc_xgmac_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCX3,c:S859,cast from 'const unsigned char *' to 'unsigned char *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MWTlwiQl6exCX4,c:S859,cast from 'const unsigned char *' to 'unsigned char *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8MXTlwiQl6exCYl,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""dev_data"" is ""struct eth_dwc_xgmac_dev_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8L-TlwiQl6exCXS,c:S3687,"Check if the usage of the type ""volatile unsigned short"" is really appropriate here (for inter-thread synchronization, atomic types are more suited).",Local variables and member data should not be volatile,"<h2>Why is this an issue?</h2>
<p>The main intended use-case for <code>volatile</code> in C and C++ is to access data that can be modified by something external to the program,
typically some hardware register. In contrast with some other languages with a <code>volatile</code> keyword, it does not provide any useful
guarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in
kernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.</p>
<p>According to the C standard:</p>
<blockquote>
  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might
  be changed by means undetectable by an implementation.</p>
</blockquote>
<p>Local variables and data members are completely controlled by the C++ language. This means they can’t change their value without the compiler
knowing about it. Therefore, it doesn’t make sense for them to be marked as <code>volatile</code>.</p>
<p>If the intent is to share those variables between threads, race conditions can be avoided by using synchronization primitives (such as
<code>std::mutex</code>) or atomic types (<code>_Atomic</code> in C11, <code>std::atomic&lt;T&gt;</code> in C++11).</p>
<p>This rule raises an issue when a local variable or class data member is declared as <code>volatile</code> (at the top level of the type, pointers
to volatile are not reported).</p>
<h3>Noncompliant code example</h3>
<pre>
volatile int counter; // Noncompliant
User * volatile vpUser; // Noncompliant; pointer is volatile
User volatile * pvUser;  // Compliant; User instance is volatile, not the pointer
</pre>
<h3>Compliant solution</h3>
<pre>
atomic_int counter;
std::atomic&lt;User*&gt; vpUser;
User volatile * pvUser;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive"">CERT CON02-C</a> - Do not
  use volatile as a synchronization primitive </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory"">CP.200: Use
  <code>volatile</code> only to talk to non-C++ memory</a> </li>
  <li> STIG Viewer - <a href=""https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222567"">Application Security and
  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>
</ul>",MAJOR,1h,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['stig-ASD_V5R3:V-222567']
AZHFJ8L-TlwiQl6exCXT,c:S3687,"Check if the usage of the type ""volatile unsigned long"" is really appropriate here (for inter-thread synchronization, atomic types are more suited).",Local variables and member data should not be volatile,"<h2>Why is this an issue?</h2>
<p>The main intended use-case for <code>volatile</code> in C and C++ is to access data that can be modified by something external to the program,
typically some hardware register. In contrast with some other languages with a <code>volatile</code> keyword, it does not provide any useful
guarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in
kernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.</p>
<p>According to the C standard:</p>
<blockquote>
  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might
  be changed by means undetectable by an implementation.</p>
</blockquote>
<p>Local variables and data members are completely controlled by the C++ language. This means they can’t change their value without the compiler
knowing about it. Therefore, it doesn’t make sense for them to be marked as <code>volatile</code>.</p>
<p>If the intent is to share those variables between threads, race conditions can be avoided by using synchronization primitives (such as
<code>std::mutex</code>) or atomic types (<code>_Atomic</code> in C11, <code>std::atomic&lt;T&gt;</code> in C++11).</p>
<p>This rule raises an issue when a local variable or class data member is declared as <code>volatile</code> (at the top level of the type, pointers
to volatile are not reported).</p>
<h3>Noncompliant code example</h3>
<pre>
volatile int counter; // Noncompliant
User * volatile vpUser; // Noncompliant; pointer is volatile
User volatile * pvUser;  // Compliant; User instance is volatile, not the pointer
</pre>
<h3>Compliant solution</h3>
<pre>
atomic_int counter;
std::atomic&lt;User*&gt; vpUser;
User volatile * pvUser;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive"">CERT CON02-C</a> - Do not
  use volatile as a synchronization primitive </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory"">CP.200: Use
  <code>volatile</code> only to talk to non-C++ memory</a> </li>
  <li> STIG Viewer - <a href=""https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222567"">Application Security and
  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>
</ul>",MAJOR,1h,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['stig-ASD_V5R3:V-222567']
AZHFJ8L-TlwiQl6exCXU,c:S3687,"Check if the usage of the type ""volatile unsigned short"" is really appropriate here (for inter-thread synchronization, atomic types are more suited).",Local variables and member data should not be volatile,"<h2>Why is this an issue?</h2>
<p>The main intended use-case for <code>volatile</code> in C and C++ is to access data that can be modified by something external to the program,
typically some hardware register. In contrast with some other languages with a <code>volatile</code> keyword, it does not provide any useful
guarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in
kernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.</p>
<p>According to the C standard:</p>
<blockquote>
  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might
  be changed by means undetectable by an implementation.</p>
</blockquote>
<p>Local variables and data members are completely controlled by the C++ language. This means they can’t change their value without the compiler
knowing about it. Therefore, it doesn’t make sense for them to be marked as <code>volatile</code>.</p>
<p>If the intent is to share those variables between threads, race conditions can be avoided by using synchronization primitives (such as
<code>std::mutex</code>) or atomic types (<code>_Atomic</code> in C11, <code>std::atomic&lt;T&gt;</code> in C++11).</p>
<p>This rule raises an issue when a local variable or class data member is declared as <code>volatile</code> (at the top level of the type, pointers
to volatile are not reported).</p>
<h3>Noncompliant code example</h3>
<pre>
volatile int counter; // Noncompliant
User * volatile vpUser; // Noncompliant; pointer is volatile
User volatile * pvUser;  // Compliant; User instance is volatile, not the pointer
</pre>
<h3>Compliant solution</h3>
<pre>
atomic_int counter;
std::atomic&lt;User*&gt; vpUser;
User volatile * pvUser;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive"">CERT CON02-C</a> - Do not
  use volatile as a synchronization primitive </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory"">CP.200: Use
  <code>volatile</code> only to talk to non-C++ memory</a> </li>
  <li> STIG Viewer - <a href=""https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222567"">Application Security and
  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>
</ul>",MAJOR,1h,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['stig-ASD_V5R3:V-222567']
AZHFJ8L-TlwiQl6exCXV,c:S3687,"Check if the usage of the type ""volatile unsigned long"" is really appropriate here (for inter-thread synchronization, atomic types are more suited).",Local variables and member data should not be volatile,"<h2>Why is this an issue?</h2>
<p>The main intended use-case for <code>volatile</code> in C and C++ is to access data that can be modified by something external to the program,
typically some hardware register. In contrast with some other languages with a <code>volatile</code> keyword, it does not provide any useful
guarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in
kernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.</p>
<p>According to the C standard:</p>
<blockquote>
  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might
  be changed by means undetectable by an implementation.</p>
</blockquote>
<p>Local variables and data members are completely controlled by the C++ language. This means they can’t change their value without the compiler
knowing about it. Therefore, it doesn’t make sense for them to be marked as <code>volatile</code>.</p>
<p>If the intent is to share those variables between threads, race conditions can be avoided by using synchronization primitives (such as
<code>std::mutex</code>) or atomic types (<code>_Atomic</code> in C11, <code>std::atomic&lt;T&gt;</code> in C++11).</p>
<p>This rule raises an issue when a local variable or class data member is declared as <code>volatile</code> (at the top level of the type, pointers
to volatile are not reported).</p>
<h3>Noncompliant code example</h3>
<pre>
volatile int counter; // Noncompliant
User * volatile vpUser; // Noncompliant; pointer is volatile
User volatile * pvUser;  // Compliant; User instance is volatile, not the pointer
</pre>
<h3>Compliant solution</h3>
<pre>
atomic_int counter;
std::atomic&lt;User*&gt; vpUser;
User volatile * pvUser;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive"">CERT CON02-C</a> - Do not
  use volatile as a synchronization primitive </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory"">CP.200: Use
  <code>volatile</code> only to talk to non-C++ memory</a> </li>
  <li> STIG Viewer - <a href=""https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222567"">Application Security and
  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>
</ul>",MAJOR,1h,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['stig-ASD_V5R3:V-222567']
AZHFJ8L-TlwiQl6exCXZ,c:S125,Remove the commented out code.,Sections of code should not be commented out,"<h2>Why is this an issue?</h2>
<p>Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.</p>
<p>Commented-out code should be deleted and can be retrieved from source control history if required.</p>
<h3>Exceptions</h3>
<p>This rule does not apply to code documentation using Doxygen, QDoc, markdown, or HTML tags.</p>
<h2>Resources</h2>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 2.4 - Sections of code should not be ""commented out"". </li>
  <li> MISRA C++:2008, 2-7-2 - Sections of code shall not be ""commented out"" using C-style comments. </li>
  <li> MISRA C++:2008, 2-7-3 - Sections of code should not be ""commented out"" using C++ comments. </li>
  <li> MISRA C:2012, Dir. 4.4 - Sections of code should not be ""commented out"" </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8L-TlwiQl6exCXW,c:S3687,"Check if the usage of the type ""volatile unsigned int"" is really appropriate here (for inter-thread synchronization, atomic types are more suited).",Local variables and member data should not be volatile,"<h2>Why is this an issue?</h2>
<p>The main intended use-case for <code>volatile</code> in C and C++ is to access data that can be modified by something external to the program,
typically some hardware register. In contrast with some other languages with a <code>volatile</code> keyword, it does not provide any useful
guarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in
kernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.</p>
<p>According to the C standard:</p>
<blockquote>
  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might
  be changed by means undetectable by an implementation.</p>
</blockquote>
<p>Local variables and data members are completely controlled by the C++ language. This means they can’t change their value without the compiler
knowing about it. Therefore, it doesn’t make sense for them to be marked as <code>volatile</code>.</p>
<p>If the intent is to share those variables between threads, race conditions can be avoided by using synchronization primitives (such as
<code>std::mutex</code>) or atomic types (<code>_Atomic</code> in C11, <code>std::atomic&lt;T&gt;</code> in C++11).</p>
<p>This rule raises an issue when a local variable or class data member is declared as <code>volatile</code> (at the top level of the type, pointers
to volatile are not reported).</p>
<h3>Noncompliant code example</h3>
<pre>
volatile int counter; // Noncompliant
User * volatile vpUser; // Noncompliant; pointer is volatile
User volatile * pvUser;  // Compliant; User instance is volatile, not the pointer
</pre>
<h3>Compliant solution</h3>
<pre>
atomic_int counter;
std::atomic&lt;User*&gt; vpUser;
User volatile * pvUser;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive"">CERT CON02-C</a> - Do not
  use volatile as a synchronization primitive </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory"">CP.200: Use
  <code>volatile</code> only to talk to non-C++ memory</a> </li>
  <li> STIG Viewer - <a href=""https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222567"">Application Security and
  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>
</ul>",MAJOR,1h,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['stig-ASD_V5R3:V-222567']
AZHFJ8L-TlwiQl6exCXX,c:S3687,"Check if the usage of the type ""volatile unsigned int"" is really appropriate here (for inter-thread synchronization, atomic types are more suited).",Local variables and member data should not be volatile,"<h2>Why is this an issue?</h2>
<p>The main intended use-case for <code>volatile</code> in C and C++ is to access data that can be modified by something external to the program,
typically some hardware register. In contrast with some other languages with a <code>volatile</code> keyword, it does not provide any useful
guarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in
kernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.</p>
<p>According to the C standard:</p>
<blockquote>
  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might
  be changed by means undetectable by an implementation.</p>
</blockquote>
<p>Local variables and data members are completely controlled by the C++ language. This means they can’t change their value without the compiler
knowing about it. Therefore, it doesn’t make sense for them to be marked as <code>volatile</code>.</p>
<p>If the intent is to share those variables between threads, race conditions can be avoided by using synchronization primitives (such as
<code>std::mutex</code>) or atomic types (<code>_Atomic</code> in C11, <code>std::atomic&lt;T&gt;</code> in C++11).</p>
<p>This rule raises an issue when a local variable or class data member is declared as <code>volatile</code> (at the top level of the type, pointers
to volatile are not reported).</p>
<h3>Noncompliant code example</h3>
<pre>
volatile int counter; // Noncompliant
User * volatile vpUser; // Noncompliant; pointer is volatile
User volatile * pvUser;  // Compliant; User instance is volatile, not the pointer
</pre>
<h3>Compliant solution</h3>
<pre>
atomic_int counter;
std::atomic&lt;User*&gt; vpUser;
User volatile * pvUser;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive"">CERT CON02-C</a> - Do not
  use volatile as a synchronization primitive </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory"">CP.200: Use
  <code>volatile</code> only to talk to non-C++ memory</a> </li>
  <li> STIG Viewer - <a href=""https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222567"">Application Security and
  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>
</ul>",MAJOR,1h,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['stig-ASD_V5R3:V-222567']
AZHFJ8L-TlwiQl6exCXY,c:S3687,"Check if the usage of the type ""volatile unsigned int"" is really appropriate here (for inter-thread synchronization, atomic types are more suited).",Local variables and member data should not be volatile,"<h2>Why is this an issue?</h2>
<p>The main intended use-case for <code>volatile</code> in C and C++ is to access data that can be modified by something external to the program,
typically some hardware register. In contrast with some other languages with a <code>volatile</code> keyword, it does not provide any useful
guarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in
kernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.</p>
<p>According to the C standard:</p>
<blockquote>
  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might
  be changed by means undetectable by an implementation.</p>
</blockquote>
<p>Local variables and data members are completely controlled by the C++ language. This means they can’t change their value without the compiler
knowing about it. Therefore, it doesn’t make sense for them to be marked as <code>volatile</code>.</p>
<p>If the intent is to share those variables between threads, race conditions can be avoided by using synchronization primitives (such as
<code>std::mutex</code>) or atomic types (<code>_Atomic</code> in C11, <code>std::atomic&lt;T&gt;</code> in C++11).</p>
<p>This rule raises an issue when a local variable or class data member is declared as <code>volatile</code> (at the top level of the type, pointers
to volatile are not reported).</p>
<h3>Noncompliant code example</h3>
<pre>
volatile int counter; // Noncompliant
User * volatile vpUser; // Noncompliant; pointer is volatile
User volatile * pvUser;  // Compliant; User instance is volatile, not the pointer
</pre>
<h3>Compliant solution</h3>
<pre>
atomic_int counter;
std::atomic&lt;User*&gt; vpUser;
User volatile * pvUser;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive"">CERT CON02-C</a> - Do not
  use volatile as a synchronization primitive </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory"">CP.200: Use
  <code>volatile</code> only to talk to non-C++ memory</a> </li>
  <li> STIG Viewer - <a href=""https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222567"">Application Security and
  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>
</ul>",MAJOR,1h,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['stig-ASD_V5R3:V-222567']
AZHFJ-VaTlwiQl6exDo6,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-VaTlwiQl6exDo3,c:S859,cast from 'const void *' to 'struct mdio_dwcxgmac_dev_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ-VaTlwiQl6exDo7,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-VaTlwiQl6exDo8,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-VaTlwiQl6exDo5,c:S1481,unused variable 'cfg',Unused local variables should be removed,"<h2>Why is this an issue?</h2>
<p>An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.</p>
<h3>What is the potential impact?</h3>
<p>Having unused local variables in your code can lead to several issues:</p>
<ul>
  <li> <strong>Decreased Readability</strong>: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
  can distract from the main logic of the code. </li>
  <li> <strong>Misunderstanding</strong>: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
  to confusion and misinterpretation of the code’s intent. </li>
  <li> <strong>Potential for Bugs</strong>: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
  declared a variable intending to use it in a calculation, but then forgot to do so, your program might not work as expected. </li>
  <li> <strong>Maintenance Issues</strong>: Unused variables can make code maintenance more difficult. If a programmer sees an unused variable, they
  might think it is a mistake and try to 'fix' the code, potentially introducing new bugs. </li>
  <li> <strong>Memory Usage</strong>: Although modern compilers are smart enough to ignore unused variables, not all compilers do this. In such cases,
  unused variables take up memory space, leading to inefficient use of resources. </li>
</ul>
<p>In summary, unused local variables can make your code less readable, more confusing, and harder to maintain, and they can potentially lead to bugs
or inefficient memory use. Therefore, it is best to remove them.</p>
<h3>Exceptions</h3>
<p>No issue is raised on local variables with the attribute <code>[[maybe_unused]]</code> or <code>unused</code> and object declarations with
non-empty arguments.</p>
<h2>How to fix it</h2>
<p>The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int numberOfMinutes(int hours) {
  int seconds = 0; // Noncompliant second is unused
  return hours * 60;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int numberOfMinutes(int hours) {
  return hours * 60;
}
</pre>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-VaTlwiQl6exDo4,c:S859,cast from 'const void *' to 'struct mdio_dwcxgmac_dev_config *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ-VaTlwiQl6exDo9,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-MoTlwiQl6exDks,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ-MoTlwiQl6exDkt,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-LaTlwiQl6exDji,c:S3646,Declare this variable in a separate statement.,Types and variables should be declared in separate statements,"<h2>Why is this an issue?</h2>
<p>It is possible in the same statement, to declare a user-defined type (<code>class</code>, <code>struct</code>, <code>union</code> or
<code>enum</code>) followed by variable declarations of this type. But mixing more than one concern in a single statement is confusing for
maintainers.</p>
<p>This rule raises an issue when a variable is declared at the end of a user-defined type declaration statement.</p>
<h3>Noncompliant code example</h3>
<pre>
struct Container { int size; } container; // Noncompliant
</pre>
<h3>Compliant solution</h3>
<pre>
struct Container { int size; };
Container container;
</pre>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement"">C.7: Don’t define a class or enum and declare a variable of its type in the same statement</a> </li>
</ul>",MINOR,2min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-LaTlwiQl6exDjh,c:S1135,"Complete the task associated to this ""TODO"" comment.","Track uses of ""TODO"" tags","<h2>Why is this an issue?</h2>
<p>Developers often use <code>TODO</code> tags to mark areas in the code where additional work or improvements are needed but are not implemented
immediately. However, these <code>TODO</code> tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to
identify and address unattended <code>TODO</code> tags to ensure a clean and maintainable codebase. This description explores why this is a problem
and how it can be fixed to improve the overall code quality.</p>
<h3>What is the potential impact?</h3>
<p>Unattended <code>TODO</code> tags in code can have significant implications for the development process and the overall codebase.</p>
<p>Incomplete Functionality: When developers leave <code>TODO</code> tags without implementing the corresponding code, it results in incomplete
functionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.</p>
<p>Missed Bug Fixes: If developers do not promptly address <code>TODO</code> tags, they might overlook critical bug fixes and security updates.
Delayed bug fixes can result in more severe issues and increase the effort required to resolve them later.</p>
<p>Impact on Collaboration: In team-based development environments, unattended <code>TODO</code> tags can hinder collaboration. Other team members
might not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.</p>
<p>Codebase Bloat: The accumulation of unattended <code>TODO</code> tags over time can clutter the codebase and make it difficult to distinguish
between work in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.</p>
<p>Addressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among
developers.</p>
<h3>Noncompliant code example</h3>
<pre>
void foo() {
  // TODO
}
</pre>
<h2>Resources</h2>
<ul>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/546"">CWE-546 - Suspicious Comment</a> </li>
</ul>",INFO,0min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",['cwe:546']
AZHFJ-LaTlwiQl6exDjj,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-LgTlwiQl6exDjk,c:S954,Move this #include directive to the top of the file.,#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-LgTlwiQl6exDjl,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-LtTlwiQl6exDjo,c:S1135,"Complete the task associated to this ""TODO"" comment.","Track uses of ""TODO"" tags","<h2>Why is this an issue?</h2>
<p>Developers often use <code>TODO</code> tags to mark areas in the code where additional work or improvements are needed but are not implemented
immediately. However, these <code>TODO</code> tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to
identify and address unattended <code>TODO</code> tags to ensure a clean and maintainable codebase. This description explores why this is a problem
and how it can be fixed to improve the overall code quality.</p>
<h3>What is the potential impact?</h3>
<p>Unattended <code>TODO</code> tags in code can have significant implications for the development process and the overall codebase.</p>
<p>Incomplete Functionality: When developers leave <code>TODO</code> tags without implementing the corresponding code, it results in incomplete
functionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.</p>
<p>Missed Bug Fixes: If developers do not promptly address <code>TODO</code> tags, they might overlook critical bug fixes and security updates.
Delayed bug fixes can result in more severe issues and increase the effort required to resolve them later.</p>
<p>Impact on Collaboration: In team-based development environments, unattended <code>TODO</code> tags can hinder collaboration. Other team members
might not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.</p>
<p>Codebase Bloat: The accumulation of unattended <code>TODO</code> tags over time can clutter the codebase and make it difficult to distinguish
between work in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.</p>
<p>Addressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among
developers.</p>
<h3>Noncompliant code example</h3>
<pre>
void foo() {
  // TODO
}
</pre>
<h2>Resources</h2>
<ul>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/546"">CWE-546 - Suspicious Comment</a> </li>
</ul>",INFO,0min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",['cwe:546']
AZHFJ-LtTlwiQl6exDjq,c:S954,Move this #include directive to the top of the file.,#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-LtTlwiQl6exDjp,c:S3646,Declare this variable in a separate statement.,Types and variables should be declared in separate statements,"<h2>Why is this an issue?</h2>
<p>It is possible in the same statement, to declare a user-defined type (<code>class</code>, <code>struct</code>, <code>union</code> or
<code>enum</code>) followed by variable declarations of this type. But mixing more than one concern in a single statement is confusing for
maintainers.</p>
<p>This rule raises an issue when a variable is declared at the end of a user-defined type declaration statement.</p>
<h3>Noncompliant code example</h3>
<pre>
struct Container { int size; } container; // Noncompliant
</pre>
<h3>Compliant solution</h3>
<pre>
struct Container { int size; };
Container container;
</pre>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement"">C.7: Don’t define a class or enum and declare a variable of its type in the same statement</a> </li>
</ul>",MINOR,2min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-QsTlwiQl6exDm8,c:S3646,Declare this variable in a separate statement.,Types and variables should be declared in separate statements,"<h2>Why is this an issue?</h2>
<p>It is possible in the same statement, to declare a user-defined type (<code>class</code>, <code>struct</code>, <code>union</code> or
<code>enum</code>) followed by variable declarations of this type. But mixing more than one concern in a single statement is confusing for
maintainers.</p>
<p>This rule raises an issue when a variable is declared at the end of a user-defined type declaration statement.</p>
<h3>Noncompliant code example</h3>
<pre>
struct Container { int size; } container; // Noncompliant
</pre>
<h3>Compliant solution</h3>
<pre>
struct Container { int size; };
Container container;
</pre>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement"">C.7: Don’t define a class or enum and declare a variable of its type in the same statement</a> </li>
</ul>",MINOR,2min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-QsTlwiQl6exDm9,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKEqFTlwiQl6exMw3,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""mgr"" is ""struct onoff_manager *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKEqFTlwiQl6exMw4,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""cli"" is ""struct onoff_client *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKEqFTlwiQl6exMw5,c:S936,"Either add a parameter list or the ""&"" operator to this use of ""sample_notify_cb"".","Function names should be used either as a call with a parameter list or with the ""&"" operator","<h2>Why is this an issue?</h2>
<p>Using a ""bald"" function name is likely a bug. Rather than testing the return value of a function with a <code>void</code> parameter list, it
implicitly retrieves the address of that function in memory. If that’s truly what’s intended, then it should be made explicit with the use of the
<code>&amp;</code> (address-of) operator. If it’s not, then a parameter list (even an empty one) should be added after the function name.</p>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int func(void) {
  // ...
}

void f2(int a, int b) {
  // ...
  if (func) {  // Noncompliant: tests that the memory address of func() is non-null
    //...
  }
  // ...
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int func(void) {
  // ...
}

void f2(int a, int b) {
  // ...
  if (func()) {  // Compliant: tests that the return value of func() &gt; 0
    //...
  }
  // ...
}
</pre>
<h3>Exceptions</h3>
<p>Callback functions are a common occurrence and are usually not passed with a preceding <code>&amp;</code>. However, there is little ambiguity, so
this rule ignores function identifiers when used as a parameter of a function call.</p>
<pre>
void foo() {
  // ...
}

registerEvent(AnEvent, foo); // Compliant by exception
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 16.9 - A function identifier shall only be used with either a preceding &amp;, or with a parenthesized parameter list, which may
  be empty. </li>
  <li> MISRA C++:2008, 8-4-4 - A function identifier shall only be used to call the function or it shall be preceded by &amp;. </li>
</ul>",CRITICAL,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ-G5TlwiQl6exDd1,c:S108,"Fill this compound statement, remove it, or add a nested comment explaining why it is empty.",Nested blocks of code should not be left empty,"<h2>Why is this an issue?</h2>
<p>An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.</p>
<pre>
void foo()
{
  int x;
  if (x == 42)
  // Noncompliant - the following nested block is empty
  {
  }
  else
  {
    doSomething();
  }
}
</pre>
<p>Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.</p>
<pre>
void foo()
{
  int x;
  if (x != 42)
  {
    doSomething();
  }
}
</pre>
<h3>Exceptions</h3>
<ul>
  <li> The rule ignores code blocks that contain comments. </li>
  <li> Functions are not nested blocks, so they can be empty. </li>
</ul>
<pre>
void bar()
// Compliant - functions are not nested blocks
{
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-G5TlwiQl6exDd2,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""priv"" is ""struct rpi_pico_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-G5TlwiQl6exDd3,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""cfg"" is ""struct udc_ep_config *const"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-G5TlwiQl6exDd4,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""cfg"" is ""struct udc_ep_config *const"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-G6TlwiQl6exDd7,c:S1854,Value stored to 'err' is never read,Unused assignments should be removed,"<p>Unused assignments should be removed.</p>
<h2>Why is this an issue?</h2>
<p>Computing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.</p>
<p>Assigning a value to a local variable that is not read by any subsequent instruction is called a <em>dead store</em>. The following code snippet
depicts a few dead stores.</p>
<pre>
int foo() {
  int x = 0; // Noncompliant: dead store, next line overwrites x
  x = 100; // Noncompliant: dead store, next line overwrites x
  x = 200;
  int y = 0;
  y += 9001; // Noncompliant: dead store, y is never used
  int z = 300; // Noncompliant: dead store, next line overwrites z
  z = 400;
  return x + z * 2;
}
</pre>
<p>Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In
most cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code
should be removed to prevent logic errors.</p>
<h2>What is the potential impact?</h2>
<p>Not only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the
absence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.</p>
<p>Unused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover
and eventually prevent logic errors.</p>
<h2>How to fix it</h2>
<p>Remove unused values and superfluous code.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int foo(int y) {
  int x = 0;
  x = 100; // Noncompliant: dead store
  x = 200;
  return x + y;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int foo(int y) {
  int x = 200; // Compliant: no unnecessary assignment
  return x + y;
}
</pre>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  if (x != 0) {
    int y = buz();
    y += 9001; // Noncompliant: dead store
  }
  return x;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // Compliant: no more dead stores and superfluous code
  // Assuming call to buz() had no important side effects
  return x;
}
</pre>
<h3>Pitfalls</h3>
<p>When removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.</p>
<p>While it is safe to remove the call to <code>square</code> in the following code since it has no side effects, removing the call to
<code>fwrite</code> changes the program’s behavior. Still, values that are never read such as <code>n</code> indicate code smells that should be
mitigated. In this code example, the return value of <code>fwrite</code> should be checked and any potential error should be handled
appropriately.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int square(int n) {
  return n * n;
}

int foo(int i) {
  int sq = square(i); // Noncompliant: dead store, assignment can be removed
  const char* const str = ""Hello, World!\n"";
  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects
  size_t n = fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read
  return i + 9001;
}
</pre>
<h3>Going the extra mile</h3>
<p>In C++17, the <code>nodiscard</code> attribute has been introduced which can be used to annotate functions, enumerations and classes.</p>
<p>The attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is
marked <code>nodiscard</code> whose return value is ignored encourages the compiler to issue a warning. Example usages of the <code>nodiscard</code>
attribute are shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }
int bar() { return 200; }
[[nodiscard(""An explanation on why not to discard the return value"")]] int buz() { return 300; }

enum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };
important_error_info compute() {
  // More code ...
  // In case of a critical error, return corresponding error info:
  return important_error_info::CRITICAL;
}

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  bar(); // compiler will issue no warning
  buz(); // compiler warns on discarding a nodiscard value
  compute(); // compiler warns on discarding a nodiscard value
}
</pre>
<p>In case, the return value of a function marked as <code>nodiscard</code> should be (exceptionally) ignored, a cast to <code>void</code> can be used
to silence the compiler warning as shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  (void)foo(); // compiler will issue no warning
}
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> CERT - <a href=""https://wiki.sei.cmu.edu/confluence/x/39UxBQ"">MSC13-C. Detect and remove unused values</a> </li>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/563"">CWE-563 - Assignment to Variable without Use ('Unused Variable')</a> </li>
</ul>
<h3>Related rules</h3>
<ul>
  <li> {rule:c:S1763} - All code should be reachable </li>
  <li> {rule:c:S2583} - Conditionally executed code should be reachable </li>
</ul>",MAJOR,1min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:563']
AZHFJ-G5TlwiQl6exDd5,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""arg"" is ""void *const"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-G6TlwiQl6exDd6,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8GsTlwiQl6exCVk,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""argv"" is ""char *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8YMTlwiQl6exCff,c:S859,cast from 'const unsigned char *' to 'unsigned char *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKH1CTlwiQl6exQlh,c:S3776,Refactor this function to reduce its Cognitive Complexity from 32 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKH1CTlwiQl6exQli,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKH1CTlwiQl6exQlk,c:S824,"Move this function declaration outside of this block scope, or if the intent was to declare a variable, use a syntax that avoids the most vexing parse.",Functions should not be declared at block scope,"<h2>Why is this an issue?</h2>
<p>It is rarely useful to declare a function at block scope. Such a function will not get special access to any name in its enclosing scope, and
therefore, it is equivalent but clearer to declare it instead in the enclosing namespace.</p>
<p>Additionally, when a function is declared at block scope, the intent is often not to declare a function but instead to declare and initialize a
variable. This problem is nicknamed the <em>most vexing parse</em> and stems from the fact that some syntaxes can be ambiguous, and that in that case
the language unintuitively favors function declaration:</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void f() {
  int a;
  string b();
  short c(short (a));
}
</pre>
<ul>
  <li> <code>b</code> could be interpreted as:
    <ul>
      <li> A variable of type <code>string</code> with empty initialization or </li>
      <li> A function with no argument and returning a <code>string</code>. </li>
    </ul>   The second interpretation is selected.  </li>
  <li> Similarly, <code>c</code> could be interpreted as:
    <ul>
      <li> A variable of type <code>short</code> initialized with the value <code>a</code> converted to <code>short</code> or </li>
      <li> A function that takes a parameter named <code>a</code> (with extra parentheses) of type <code>short</code> and returning a
      <code>short</code> </li>
    </ul>   Here again, the second interpretation is selected.  </li>
</ul>
<p>There are several ways to write the code differently so that <code>b</code> and <code>c</code> can only be interpreted as variables. For
instance:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void f() {
  int a;
  string b {};
  auto c = short (a);
}
</pre>
<p>By raising issues on local function declaration, this rule helps detect when a function is inadvertently declared.</p>
<h2>How to fix it</h2>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
class A {
};

void fun() {
  void nestedFun();  // Noncompliant; declares a function in block scope

  A a();      // Noncompliant; declares a function at block scope, not an object
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
class A {
};

void nestedFun(); // Compliant, function declaration moved outside of fun

void fun() {
  A a;      // Compliant; declares an object
}
</pre>
<h2>Resources</h2>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2023, 6.0.1 - Block scope declarations shall not be visually ambiguous </li>
  <li> MISRA C++:2008, 3-1-2 - Functions shall not be declared at block scope </li>
  <li> MISRA C:2004, 8.6 - Functions shall be declared at file scope </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ87GTlwiQl6exCy9,c:S954,"Move all #include directives to the very top of the file, before any code.",#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8-NTlwiQl6exC09,c:S954,"Move all #include directives to the very top of the file, before any code.",#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9AjTlwiQl6exC2d,c:S954,"Move all #include directives to the very top of the file, before any code.",#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8_vTlwiQl6exC1x,c:S954,"Move all #include directives to the very top of the file, before any code.",#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ878TlwiQl6exCz4,c:S936,"Either add a parameter list or the ""&"" operator to this use of ""spi_rtio_iodev_default_submit"".","Function names should be used either as a call with a parameter list or with the ""&"" operator","<h2>Why is this an issue?</h2>
<p>Using a ""bald"" function name is likely a bug. Rather than testing the return value of a function with a <code>void</code> parameter list, it
implicitly retrieves the address of that function in memory. If that’s truly what’s intended, then it should be made explicit with the use of the
<code>&amp;</code> (address-of) operator. If it’s not, then a parameter list (even an empty one) should be added after the function name.</p>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int func(void) {
  // ...
}

void f2(int a, int b) {
  // ...
  if (func) {  // Noncompliant: tests that the memory address of func() is non-null
    //...
  }
  // ...
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int func(void) {
  // ...
}

void f2(int a, int b) {
  // ...
  if (func()) {  // Compliant: tests that the return value of func() &gt; 0
    //...
  }
  // ...
}
</pre>
<h3>Exceptions</h3>
<p>Callback functions are a common occurrence and are usually not passed with a preceding <code>&amp;</code>. However, there is little ambiguity, so
this rule ignores function identifiers when used as a parameter of a function call.</p>
<pre>
void foo() {
  // ...
}

registerEvent(AnEvent, foo); // Compliant by exception
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 16.9 - A function identifier shall only be used with either a preceding &amp;, or with a parenthesized parameter list, which may
  be empty. </li>
  <li> MISRA C++:2008, 8-4-4 - A function identifier shall only be used to call the function or it shall be preceded by &amp;. </li>
</ul>",CRITICAL,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ9BITlwiQl6exC2w,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""dt_spec"" is ""struct spi_dt_spec *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9BITlwiQl6exC2z,c:S1854,Value stored to 'dev' during its initialization is never read,Unused assignments should be removed,"<p>Unused assignments should be removed.</p>
<h2>Why is this an issue?</h2>
<p>Computing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.</p>
<p>Assigning a value to a local variable that is not read by any subsequent instruction is called a <em>dead store</em>. The following code snippet
depicts a few dead stores.</p>
<pre>
int foo() {
  int x = 0; // Noncompliant: dead store, next line overwrites x
  x = 100; // Noncompliant: dead store, next line overwrites x
  x = 200;
  int y = 0;
  y += 9001; // Noncompliant: dead store, y is never used
  int z = 300; // Noncompliant: dead store, next line overwrites z
  z = 400;
  return x + z * 2;
}
</pre>
<p>Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In
most cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code
should be removed to prevent logic errors.</p>
<h2>What is the potential impact?</h2>
<p>Not only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the
absence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.</p>
<p>Unused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover
and eventually prevent logic errors.</p>
<h2>How to fix it</h2>
<p>Remove unused values and superfluous code.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int foo(int y) {
  int x = 0;
  x = 100; // Noncompliant: dead store
  x = 200;
  return x + y;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int foo(int y) {
  int x = 200; // Compliant: no unnecessary assignment
  return x + y;
}
</pre>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  if (x != 0) {
    int y = buz();
    y += 9001; // Noncompliant: dead store
  }
  return x;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // Compliant: no more dead stores and superfluous code
  // Assuming call to buz() had no important side effects
  return x;
}
</pre>
<h3>Pitfalls</h3>
<p>When removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.</p>
<p>While it is safe to remove the call to <code>square</code> in the following code since it has no side effects, removing the call to
<code>fwrite</code> changes the program’s behavior. Still, values that are never read such as <code>n</code> indicate code smells that should be
mitigated. In this code example, the return value of <code>fwrite</code> should be checked and any potential error should be handled
appropriately.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int square(int n) {
  return n * n;
}

int foo(int i) {
  int sq = square(i); // Noncompliant: dead store, assignment can be removed
  const char* const str = ""Hello, World!\n"";
  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects
  size_t n = fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read
  return i + 9001;
}
</pre>
<h3>Going the extra mile</h3>
<p>In C++17, the <code>nodiscard</code> attribute has been introduced which can be used to annotate functions, enumerations and classes.</p>
<p>The attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is
marked <code>nodiscard</code> whose return value is ignored encourages the compiler to issue a warning. Example usages of the <code>nodiscard</code>
attribute are shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }
int bar() { return 200; }
[[nodiscard(""An explanation on why not to discard the return value"")]] int buz() { return 300; }

enum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };
important_error_info compute() {
  // More code ...
  // In case of a critical error, return corresponding error info:
  return important_error_info::CRITICAL;
}

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  bar(); // compiler will issue no warning
  buz(); // compiler warns on discarding a nodiscard value
  compute(); // compiler warns on discarding a nodiscard value
}
</pre>
<p>In case, the return value of a function marked as <code>nodiscard</code> should be (exceptionally) ignored, a cast to <code>void</code> can be used
to silence the compiler warning as shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  (void)foo(); // compiler will issue no warning
}
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> CERT - <a href=""https://wiki.sei.cmu.edu/confluence/x/39UxBQ"">MSC13-C. Detect and remove unused values</a> </li>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/563"">CWE-563 - Assignment to Variable without Use ('Unused Variable')</a> </li>
</ul>
<h3>Related rules</h3>
<ul>
  <li> {rule:c:S1763} - All code should be reachable </li>
  <li> {rule:c:S2583} - Conditionally executed code should be reachable </li>
</ul>",MAJOR,1min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:563']
AZHFJ9BITlwiQl6exC2u,c:S859,cast from 'const unsigned char *' to 'unsigned char *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ9BITlwiQl6exC2v,c:S859,cast from 'const unsigned char *' to 'unsigned char *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ9BITlwiQl6exC2x,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""tx_buf_ptr"" is ""struct spi_buf_set *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9BITlwiQl6exC2y,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""rx_buf_ptr"" is ""struct spi_buf_set *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-l,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-m,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-n,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-o,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-p,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-q,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-r,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-s,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-u,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-v,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-w,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-y,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-0,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-1,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-2,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-3,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGSETlwiQl6exO-5,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKB86TlwiQl6exHH7,c:S1172,"Remove the unused parameter ""conn"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKB86TlwiQl6exHH8,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""conn"" is ""struct bt_conn *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGWETlwiQl6exPEC,c:S859,cast from 'const char *' to 'unsigned char *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKGXdTlwiQl6exPHG,c:S1172,"Remove the unused parameter ""data"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKGXdTlwiQl6exPHH,c:S1172,"Remove the unused parameter ""user_data"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKGXdTlwiQl6exPHI,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""data"" is ""struct bt_data *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGXdTlwiQl6exPHJ,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""user_data"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGYhTlwiQl6exPHr,c:S954,Move these 4 #include directives to the top of the file.,#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKGWETlwiQl6exPEA,c:S859,cast from 'const char *' to 'unsigned char *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKGWETlwiQl6exPEB,c:S859,cast from 'const char *' to 'unsigned char *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKIgzTlwiQl6exRF1,python:S1192,Define a constant instead of duplicating this literal 'samples/drivers/led_strip/README' 4 times.,String literals should not be duplicated,"<h2>Why is this an issue?</h2>
<p>Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.</p>
<h3>Exceptions</h3>
<p>No issue will be raised on:</p>
<ul>
  <li> duplicated string in decorators </li>
  <li> strings with less than 5 characters </li>
  <li> strings with only letters, numbers and underscores </li>
</ul>
<h2>How to fix it</h2>
<p>Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<p>With the default threshold of 3:</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def run():
    prepare(""action1"")  # Noncompliant - ""action1"" is duplicated 3 times
    execute(""action1"")
    release(""action1"")

@app.route(""/api/users/"", methods=['GET', 'POST', 'PUT'])
def users():
    pass

@app.route(""/api/projects/"", methods=['GET', 'POST', 'PUT'])  # Compliant - strings inside decorators are ignored
def projects():
    pass
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
ACTION_1 = ""action1""

def run():
    prepare(ACTION_1)
    execute(ACTION_1)
    release(ACTION_1)
</pre>",CRITICAL,2min,DISTINCT,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKILjTlwiQl6exQ0J,python:S3776,Refactor this function to reduce its Cognitive Complexity from 29 to the 15 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 5.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def process_eligible_users(users):
    for user in users:             # +1 (for)
        if ((user.is_active and    # +1 (if) +1 (nested) +1 (multiple conditions)
            user.has_profile) or   # +1 (mixed operator)
            user.age &gt; 18 ):
            user.process()
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>process_eligible_users</code> function, which now only has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def process_eligible_users(users):
    for user in users:             # +1 (for)
        if is_eligible_user(user): # +1 (if) +1 (nested)
            user.process()

def is_eligible_user(user):
    return ((user.is_active and user.has_profile) or user.age &gt; 18) # +1 (multiple conditions) +1 (mixed operators)
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p><em>Note:</em> The code is simplified here, to illustrate the purpose. Please imagine there is more happening in the process.<br></p>
<p>The bellow code has a cognitive complexity score of 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
def process_user(user):
    if user.is_active():             # +1 (if)
        if user.has_profile():       # +1 (if) +1 (nested)
            ... # process active user with profile
        else:                        # +1 (else)
            ... # process active user without profile
    else:                            # +1 (else)
        if user.has_profile():       # +1 (if) +1 (nested)
            ... # process inactive user with profile
        else:                        # +1 (else)
            ... # process inactive user without profile
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions and the breaks in flow are no more
nested.<br> The <code>process_user</code> has now a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
def process_user(user):
    if user.is_active():             # +1 (if)
        process_active_user(user)
    else:                            # +1 (else)
        process_inactive_user(user)

def process_active_user(user):
    if user.has_profile():           # +1 (if) +1 (nested)
        ... # process active user with profile
    else:                            # +1 (else)
        ... # process active user without profile

def process_inactive_user(user):
    if user.has_profile():           # +1 (if) +1 (nested)
        ... # process inactive user with profile
    else:                            # +1 (else)
        ... # process inactive user without profile
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 6.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
def calculate(data):
    if data is not None:  # +1 (if)
        total = 0
        for item in data: # +1 (for) +1 (nested)
            if item &gt; 0:  # +1 (if)  +2 (nested)
                total += item * 2
        return total
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 4.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
def calculate(data):
    if data is None:      # +1 (if)
        return None
    total = 0
    for item in data:     # +1 (for)
        if item &gt; 0:      # +1 (if) +1 (nested)
            total += item * 2
    return total
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8YGTlwiQl6exCfe,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""iodev_sqe"" is ""struct rtio_iodev_sqe *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8YGTlwiQl6exCfc,c:S859,cast from 'const unsigned char *' to 'unsigned char *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8YGTlwiQl6exCfd,c:S859,cast from 'const unsigned char *' to 'unsigned char *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKAZ1TlwiQl6exFUK,cpp:S5421,Global variables should be const.,Non-const global variables should not be used,"<h2>Why is this an issue?</h2>
<p>A global variable can be modified from anywhere in the program. At first, this might look convenient. However, it makes programs harder to
understand and maintain. When you see a function call, you cannot know if the function will affect the value of the global variable or not. You have
lost the ability to reason locally about your code and must always have the whole program in mind.</p>
<p>Additionally, global variables are often subject to race conditions in multi-threaded environments.</p>
<p>These issues are related to modification and cannot occur when the global variable is <code>const</code> (or, in the case of a pointer, if it is
<code>const</code> at every level).</p>
<pre>
unsigned** noncompliantPtr;
unsigned const* const* const compliantPtr = ...;
</pre>
<p>Some global variables defined in external libraries (such as <code>std::cout</code>, <code>std::cin</code>, <code>std::cerr</code>) are acceptable
to use, but you should have a good reason to create your own. If you use a global variable, ensure they can be safely accessed concurrently.</p>
<p>Remember that it is much easier to maintain software without globals. Instead of such variables, it is better to design functions to take as input
all the required variables. In addition to serving documentation, this also helps future refactoring and the evolution of the code.</p>
<p>This rule detects all declarations of global variables (at file scope or in any namespace) that are not constant.</p>
<h3>Noncompliant code example</h3>
<pre>
double oneFoot = 0.3048; // Noncompliant
double userValue; // Noncompliant

void readValue();
void writeResult();

int main() {
  readValue();
  writeResult();
}
</pre>
<h3>Compliant solution</h3>
<pre>
constexpr double footToMeter = 0.3048;

double readValueInFeet();
void writeResult(double valueInMeters);

int main() {
  auto userValue = readValueInFeet();
  writeResult(userValue * footToMeter);
}
</pre>
<h3>Exceptions</h3>
<p><code>volatile</code> is used to indicate that some piece of memory can be mutated by external factors. For embedded software, some hardware
inputs/outputs can be mapped to specific memory addresses, and accessing these bound data is usually done through a global pointer to
<code>volatile</code> data.</p>
<p>In that situation, the pointer itself should be const, but the pointee can be non-const if the memory maps an output register that is supposed to
be written to.</p>
<pre>
unsigned volatile      *       gpio1;       // Noncompliant
unsigned volatile      * const gpio2 = ...; // Compliant, used for input &amp; output
unsigned volatile const* const gpio3 = ...; // Compliant, used for input only
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i2-avoid-non-const-global-variables"">I.2: Avoid
  non-<code>const</code> global variables</a> </li>
  <li> STIG Viewer - <a href=""https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222567"">Application Security and
  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Stack Overflow - Answer by Gabriel Staples for <a href=""https://stackoverflow.com/a/73027793/24103368"">What is the point of declaring ""const
  volatile int *p""?</a> </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",['stig-ASD_V5R3:V-222567']
AZHFKAZ1TlwiQl6exFUL,cpp:S1172,"Remove the unused parameter ""target"", make it unnamed, or declare it ""[[maybe_unused]]"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZ1TlwiQl6exFUM,cpp:S1172,"Remove the unused parameter ""parent"", make it unnamed, or declare it ""[[maybe_unused]]"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZ1TlwiQl6exFUN,cpp:S1172,"Remove the unused parameter ""dev"", make it unnamed, or declare it ""[[maybe_unused]]"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFTw,cpp:S995,"Make the type of this parameter a pointer-to-const. The current type of ""fixture"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKAZvTlwiQl6exFUJ,cpp:S5008,"Replace this use of ""void *"" with a more meaningful type.","""void *"" should not be used in typedefs, member variables, function parameters or return type","<h2>Why is this an issue?</h2>
<p><code>void*</code> is a pointer to memory of unknown type, and therefore works outside of the safety net provided by the type system. While it can
be useful in a function body to interface with external code, there is no good reason to step out of the robust C++ type system when defining a
function, either for the function parameters, or for the function return type. For the same reasons, having a member variable of type
<code>void*</code> is not recommended.</p>
<p>If you want to work with raw memory buffer, use <code>unsigned char *</code> (or <code>byte *</code> if your compiler supports it).</p>
<p>If you want to work with different types of data, define a function template and use typed pointers, instead of <code>void *</code>. If you want a
single object to be able to stores objects of different types, <code>std::any</code> can also be a type-safe alternative to <code>void*</code>.</p>
<p>If you want to provide to users of an API an opaque type, declare a type and don’t provide its definition (like with <code>FILE*</code>).</p>
<p>Note that <code>void*</code> is commonly used to communicate data of unknown type with C code. This rule will nevertheless raise an issue in this
case, but it can be ignored.</p>
<h3>Noncompliant code example</h3>
<pre>
void saveBuffer(void *buffer, size_t size); // Noncompliant
void duplicate(void* destination, size_t count, void *source, size_t size); // Noncompliant
class Process {
  // ...
  void *userData;
};
using UserData = void*; // Noncompliant
</pre>
<h3>Compliant solution</h3>
<pre>
void saveBuffer(unsigned char *buffer, size_t size);
template&lt;class T&gt;
void duplicate(T* destination, size_t count, T *source);
class Process {
  // ...
  std::any userData;
};
</pre>
<h3>Exceptions</h3>
<p><code>void*</code> can be useful when interfacing with C. As such, the rule will ignore <code>extern ""C""</code> functions, as well as types with
standard layout.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i4-make-interfaces-precisely-and-strongly-typed"">I.4: Make
  interfaces precisely and strongly typed</a> </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t3-use-templates-to-express-containers-and-ranges"">T.3: Use
  templates to express containers and ranges</a> </li>
</ul>",CRITICAL,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKAZvTlwiQl6exFTx,cpp:S1116,"Modify the macro definition so that it needs to be followed by a semicolon, or remove this empty statement.",Empty statements should be removed,"<h2>Why is this an issue?</h2>
<p>Empty statements represented by a semicolon <code>;</code> are statements that do not perform any operation. They are often the result of a typo or
a misunderstanding of the language syntax. It is a good practice to remove empty statements since they don’t add value and lead to confusion and
errors.</p>
<h3>Exceptions</h3>
<p>In the case of an empty expanded macro, the issue is not raised.</p>
<pre>
#define LOG(x)

void fun() {
  LOG(X);
}
</pre>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething() {
  ;                // Noncompliant - was used as a kind of TODO marker
}

#define A(x) x;    // Noncompliant - macro definitions should not end with a semi-colon when they are used as functions

void fun() {
  A(5);            // Noncompliant - after expansion, there are 2 consecutive semi-colons
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething() {
}

#define A(x) x

void fun() {
  A(5);
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that
  the first character following the null statement is a white-space character. </li>
  <li> MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided
  that the first character following the null statement is a white-space character. </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/WtYxBQ"">CERT, EXP15-C.</a> - Do not place a semicolon on the same line as an if, for, or while
  statement </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKAZvTlwiQl6exFTy,cpp:S4962,"Use the ""nullptr"" literal.","""nullptr"" should be used to denote the null pointer","<h2>Why is this an issue?</h2>
<p>Before C++11, the only way to refer to a null pointer was by using the integer literal <code>0</code>, which created ambiguity about whether a
pointer or an integer was intended. Even with the <code>NULL</code> macro, the underlying value is still <code>0</code>.</p>
<p>C++11 introduced the keyword <code>nullptr</code>, which unambiguously refers to the null pointer. It should be used systematically.</p>
<pre>
void f(char *c);
void g(int);
void usage()
{
    f(0); // Noncompliant
    f(NULL); // Noncompliant
    f(nullptr); // Compliant: unambiguous

    g(0); // Compliant, a real integer
    // g(nullptr); // This would not compile
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> C++ reference - <a href=""https://en.cppreference.com/w/cpp/language/nullptr"">nullptr</a> </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es47-use-nullptr-rather-than-0-or-null"">ES.47: Use
  <code>nullptr</code> rather than <code>0</code> or <code>NULL</code></a> </li>
</ul>",CRITICAL,1min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKAZvTlwiQl6exFTz,cpp:S4962,"Use the ""nullptr"" literal.","""nullptr"" should be used to denote the null pointer","<h2>Why is this an issue?</h2>
<p>Before C++11, the only way to refer to a null pointer was by using the integer literal <code>0</code>, which created ambiguity about whether a
pointer or an integer was intended. Even with the <code>NULL</code> macro, the underlying value is still <code>0</code>.</p>
<p>C++11 introduced the keyword <code>nullptr</code>, which unambiguously refers to the null pointer. It should be used systematically.</p>
<pre>
void f(char *c);
void g(int);
void usage()
{
    f(0); // Noncompliant
    f(NULL); // Noncompliant
    f(nullptr); // Compliant: unambiguous

    g(0); // Compliant, a real integer
    // g(nullptr); // This would not compile
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> C++ reference - <a href=""https://en.cppreference.com/w/cpp/language/nullptr"">nullptr</a> </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es47-use-nullptr-rather-than-0-or-null"">ES.47: Use
  <code>nullptr</code> rather than <code>0</code> or <code>NULL</code></a> </li>
</ul>",CRITICAL,1min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKAZvTlwiQl6exFT0,cpp:S5945,"Use ""std::string"" instead of a C-style char array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFT1,cpp:S995,"Make the type of this parameter a pointer-to-const. The current type of ""msgs"" is ""struct i2c_msg *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKAZvTlwiQl6exFT2,cpp:S4962,"Use the ""nullptr"" literal.","""nullptr"" should be used to denote the null pointer","<h2>Why is this an issue?</h2>
<p>Before C++11, the only way to refer to a null pointer was by using the integer literal <code>0</code>, which created ambiguity about whether a
pointer or an integer was intended. Even with the <code>NULL</code> macro, the underlying value is still <code>0</code>.</p>
<p>C++11 introduced the keyword <code>nullptr</code>, which unambiguously refers to the null pointer. It should be used systematically.</p>
<pre>
void f(char *c);
void g(int);
void usage()
{
    f(0); // Noncompliant
    f(NULL); // Noncompliant
    f(nullptr); // Compliant: unambiguous

    g(0); // Compliant, a real integer
    // g(nullptr); // This would not compile
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> C++ reference - <a href=""https://en.cppreference.com/w/cpp/language/nullptr"">nullptr</a> </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es47-use-nullptr-rather-than-0-or-null"">ES.47: Use
  <code>nullptr</code> rather than <code>0</code> or <code>NULL</code></a> </li>
</ul>",CRITICAL,1min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKAZvTlwiQl6exFT3,cpp:S5945,"Use ""std::string"" instead of a C-style char array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFT4,cpp:S995,"Make the type of this parameter a pointer-to-const. The current type of ""msgs"" is ""struct i2c_msg *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKAZvTlwiQl6exFT5,cpp:S5945,"Use ""std::string"" instead of a C-style char array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFT6,cpp:S5945,"Use ""std::string"" instead of a C-style char array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFT7,cpp:S5945,"Use ""std::string"" instead of a C-style char array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFT8,cpp:S5945,"Use ""std::string"" instead of a C-style char array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFT9,cpp:S5945,"Use ""std::string"" instead of a C-style char array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFT-,cpp:S5945,"Use ""std::string"" instead of a C-style char array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFT_,cpp:S5945,"Use ""std::string"" instead of a C-style char array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFUA,cpp:S5945,"Use ""std::string"" instead of a C-style char array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFUC,cpp:S5945,"Use ""std::array"" or ""std::vector"" instead of a C-style array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFUD,cpp:S5945,"Use ""std::string"" instead of a C-style char array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFUE,cpp:S5945,"Use ""std::array"" or ""std::vector"" instead of a C-style array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFUF,cpp:S995,"Make the type of this parameter a pointer-to-const. The current type of ""msgs"" is ""struct i2c_msg *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKAZvTlwiQl6exFUG,cpp:S5945,"Use ""std::array"" or ""std::vector"" instead of a C-style array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFUH,cpp:S5945,"Use ""std::array"" or ""std::vector"" instead of a C-style array.",C-style array should not be used,"<h2>Why is this an issue?</h2>
<p>C-style arrays (such as <code>int i[10]</code>) are not very convenient to use:</p>
<ul>
  <li> They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) </li>
  <li> If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that ""should be
  large enough"", which is both a waste of memory and a limitation of the program) </li>
  <li> It is very easy to lose the size of the array since an array passed to a function decays into a pointer </li>
</ul>
<p>The C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:</p>
<ul>
  <li> For fixed-size arrays, where the memory is on the stack, use <code>std::array</code>. It is like a C-style array, except that it has normal
  argument passing semantics, and the size is always a part of the type. You can roll your version if <code>std::array</code> is unavailable to you
  (before C++11). </li>
  <li> For variable-size arrays, use <code>std::vector</code>. It can be resized and handles memory allocation transparently. </li>
  <li> For character strings, you should use <code>std::string</code> instead of arrays of characters. </li>
  <li> For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer <code>std::array</code> or
  <code>std::vector</code> as per the first two bullets. </li>
</ul>
<p>The rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic
memory allocation that could be replaced by <code>std::vector</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
void f() {
  int a[10]; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
void f() {
  std::array&lt;int, 10&gt; a1; // If the size really is a constant
  // Or
  std::vector&lt;int&gt;a2; // For variable size

  auto s = ""Hello!""; // Compliant by exception
}
</pre>
<h3>Exceptions</h3>
<p>This rule will not report the use of C-style arrays in <code>extern ""C""</code> code (since those arrays are often required here for compatibility
with external code) and in the arguments of <code>main</code>.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array"">SL.con.1: Prefer using STL <code>array</code> or <code>vector</code> instead of a C array</a> </li>
</ul>",MAJOR,10min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAZvTlwiQl6exFUB,cpp:S5566,"Change this raw for-loop to a range for-loop or an ""std::ranges::for_each"".",STL algorithms and range-based for loops should be preferred to traditional for loops,"<h2>Why is this an issue?</h2>
<p><code>for</code>-loops are a very powerful and versatile tool that can be used for many purposes. This flexibility comes with drawbacks:</p>
<ul>
  <li> It is very easy to make a small mistake when writing them, </li>
  <li> They are relatively verbose to write, </li>
  <li> They do not express the intent of the code, the reader has to look at loop details to understand what the loop does. </li>
</ul>
<p>There are algorithms that encapsulate a <code>for</code>-loop and give it some meaning (<code>std::all_of</code>, <code>std::count_if</code>,
<code>std::remove_if</code>…​). These algorithms are well tested, efficient, and explicit and therefore should be your first choice.</p>
<p>This rule detects loops that go through all consecutive elements of a sequence (eg: containers, objects with begin() and end() member functions),
and deal only with the current element without side-effects on the rest of the sequence.</p>
<p>This rule suggests using one of the supported STL algorithm patterns corresponding to your C++ standard when a loop matches it.</p>
<p>Currently, this rule supports:</p>
<ul>
  <li> <code>std::all_of</code> (since C++11) and <code>std::ranges::all_of</code> (since C++20): returns <code>true</code> if all elements in the
  given range are matching the given predicate, <code>false</code> otherwise </li>
  <li> <code>std::none_of</code> (since C++11) and <code>std::ranges::none_of</code> (since C++20): returns <code>true</code> if no elements in the
  given range are matching the given predicate, <code>false</code> otherwise </li>
  <li> <code>std::any_of</code> (since C++11) and <code>std::ranges::any_of</code> (since C++20): returns <code>true</code> if at least one element in
  the given range is matching the given predicate, <code>false</code> otherwise </li>
  <li> <code>std::ranges::contains</code> (since C++23): returns <code>true</code> if at least one element in the given range is equal to the given
  value, <code>false</code> otherwise </li>
</ul>
<p>This rule suggests two options below when the loop doesn’t match any of the supported STL algorithm patterns and you just want to iterate over all
elements of a sequence:</p>
<ul>
  <li> Range-based <code>for</code>-loops, which were introduced in C++11 and will run through all elements of a sequence </li>
  <li> <code>std::for_each</code>, an algorithm that performs the same operation between two iterators (allowing more flexibility, for instance by
  using <code>reverse_iterator</code>s, or with a variant that can loop in parallel on several elements at a time). </li>
</ul>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;

bool asDesired(const int v);

bool areAllDesired(std::vector&lt;int&gt; values) {
  for (int val : values) { // Noncompliant, replace it by a call to std::all_of
    if (!asDesired(val)) {
      return false;
    }
  }
  return true;
}

bool containsDesired(std::vector&lt;int&gt; values, int desired) {
  for (int val : values) { // Noncompliant
    if (val == desired) {
      return true;
    }
  }
  return false;
}

int f(vector&lt;int&gt; &amp;v) {

  for (auto it = v.begin(); it != v.end(); ++it) { // Noncompliant
    if (*it &gt; 0) {
      cout &lt;&lt; ""Positive number : "" &lt;&lt; *it &lt;&lt; endl;
    } else {
      cout &lt;&lt; ""Negative number : "" &lt;&lt; *it &lt;&lt; endl;
    }
  }

  auto sum = 0;
  for (auto it = v.begin(); it != v.end(); ++it) { // Noncompliant
    sum += *it;
  }
  return sum;
}
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

bool asDesired(const int v);

bool areAllDesired(std::vector&lt;int&gt; values) {
  return std::ranges::all_of(values, asDesired);
  // Or, before C++20:
  return std::all_of(std::begin(values), std::end(values), asDesired);
}

bool containsDesiredCpp23(std::vector&lt;int&gt; values, int desired) {
  return std::ranges::contains(values, desired);
  // Or, before C++23:
  return std::any_of(std::begin(values), std::end(values), [desired](int val) { return val == desired; });
}

void displayNumber(int i) {
  if (i &gt; 0) {
    cout &lt;&lt; ""Positive number : "" &lt;&lt; i &lt;&lt; endl;
  } else {
    cout &lt;&lt; ""Negative number : "" &lt;&lt; i &lt;&lt; endl;
  }
}

void f(vector&lt;int&gt; &amp;v) {

  std::ranges::for_each(v, displayNumber);
  // Or, before C++20:
  std::for_each(v.begin(), v.end(), displayNumber);

  auto sum = 0;
  for (auto elt : v) {
    sum += elt;
  }
  return sum;
  // An even better way to write this would be:
  // return std::accumulate(v.begin(), v.end(), 0);
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> C++ reference - <a href=""https://en.cppreference.com/w/cpp/algorithm/ranges/contains""><code>std::ranges::contains</code></a> </li>
  <li> C++ reference - <a href=""https://en.cppreference.com/w/cpp/algorithm/ranges/all_any_none_of""><code>std::ranges::all_of</code>,
  <code>std::ranges::any_of</code>, <code>std::ranges::none_of</code></a> </li>
  <li> C++ reference - <a href=""https://en.cppreference.com/w/cpp/algorithm/ranges/for_each""><code>std::ranges::for_each</code></a> </li>
  <li> C++ reference - <a href=""https://en.cppreference.com/w/cpp/algorithm/all_any_none_of""><code>std::all_of</code>, <code>std::any_of</code>,
  <code>std::none_of</code></a> </li>
  <li> C++ reference - <a href=""https://en.cppreference.com/w/cpp/algorithm/for_each""><code>std::for_each</code></a> </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice"">ES.71: Prefer a range-<code>for</code>-statement to a <code>for</code>-statement when there is a choice</a> </li>
  <li> C++ Core Guidelines - <a href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#p3-express-intent"">P.3: Express
  intent</a> </li>
</ul>",MINOR,5min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKAZvTlwiQl6exFUI,cpp:S6022,"Use ""std::byte"" for byte-oriented data manipulation.","""std::byte"" should be used when you need byte-oriented memory access","<h2>Why is this an issue?</h2>
<p>C++17 introduced <code>std::byte</code>. It allows you to have byte-oriented access to memory in a type-safe, unambiguous manner. Before, you had
to use either <code>char</code>, <code>signed char</code>, or <code>unsigned char</code> to access memory as bytes. The previous approach was
error-prone as the <code>char</code> type allows you to accidentally perform arithmetic operations. Also, it was confusing since <code>char</code>,
<code>signed char</code>, and <code>unsigned char</code> are also used to represent actual characters and arithmetic values.</p>
<p><code>std::byte</code> is simply a scoped enumeration with bit-wise operators and a helper function <code>to_integer&lt;T&gt;</code> to convert
byte object to integral type T.</p>
<p>This rule will detect byte-like usage of <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> and suggest replacing them by
<code>std::byte</code>.</p>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void handleFirstByte(char* byte);

void f(int* i) {
  char* c = reinterpret_cast&lt;char*&gt;(i); // Noncompliant
  handleFirstByte(c);
}

unsigned char negate(unsigned char byte) {
  return ~byte; // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void handleFirstByte(std::byte* byte);

void f(int* i) {
  std::byte* byte = reinterpret_cast&lt;std::byte*&gt;(i); // Compliant
  handleFirstByte(byte);
}

std::byte negate(std::byte byte) {
  return ~byte; // Compliant
}
</pre>
<h2>Resources</h2>
<ul>
  <li> C++ reference - <a href=""https://en.cppreference.com/w/cpp/types/byte"">std::byte</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ889TlwiQl6exC0m,c:S954,Move this #include directive to the top of the file.,#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ889TlwiQl6exC0n,c:S1172,"Remove the unused parameter ""config"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9mrTlwiQl6exDLP,c:S954,"Move all #include directives to the very top of the file, before any code.",#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9mrTlwiQl6exDLQ,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""req"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9mrTlwiQl6exDLO,c:S859,cast from 'const struct max32_perclk *' to 'void *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKBGGTlwiQl6exF76,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""user_data"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBGGTlwiQl6exF77,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""data"" is ""struct mbox_msg *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBGGTlwiQl6exF78,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""data"" is ""struct mbox_msg *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBGGTlwiQl6exF79,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBEZTlwiQl6exF7C,c:S1172,"Remove the unused parameter ""id"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKBEZTlwiQl6exF7D,c:S1172,"Remove the unused parameter ""expire_time"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ_iHTlwiQl6exEhn,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ_iHTlwiQl6exEhl,c:S859,cast from 'const struct rtc_time *' to 'struct rtc_time *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ_iHTlwiQl6exEho,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ_iHTlwiQl6exEhm,c:S859,cast from 'const struct rtc_time *' to 'struct rtc_time *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKIgzTlwiQl6exRF2,python:S1192,Define a constant instead of duplicating this literal 'connectivity/bluetooth/bluetooth-qual' 15 times.,String literals should not be duplicated,"<h2>Why is this an issue?</h2>
<p>Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.</p>
<h3>Exceptions</h3>
<p>No issue will be raised on:</p>
<ul>
  <li> duplicated string in decorators </li>
  <li> strings with less than 5 characters </li>
  <li> strings with only letters, numbers and underscores </li>
</ul>
<h2>How to fix it</h2>
<p>Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<p>With the default threshold of 3:</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def run():
    prepare(""action1"")  # Noncompliant - ""action1"" is duplicated 3 times
    execute(""action1"")
    release(""action1"")

@app.route(""/api/users/"", methods=['GET', 'POST', 'PUT'])
def users():
    pass

@app.route(""/api/projects/"", methods=['GET', 'POST', 'PUT'])  # Compliant - strings inside decorators are ignored
def projects():
    pass
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
ACTION_1 = ""action1""

def run():
    prepare(ACTION_1)
    execute(ACTION_1)
    release(ACTION_1)
</pre>",CRITICAL,2min,DISTINCT,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKIgzTlwiQl6exRF0,python:S1192,Define a constant instead of duplicating this literal 'connectivity/usb/device/usb_device' 4 times.,String literals should not be duplicated,"<h2>Why is this an issue?</h2>
<p>Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all
occurrences.</p>
<h3>Exceptions</h3>
<p>No issue will be raised on:</p>
<ul>
  <li> duplicated string in decorators </li>
  <li> strings with less than 5 characters </li>
  <li> strings with only letters, numbers and underscores </li>
</ul>
<h2>How to fix it</h2>
<p>Use constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single
place.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<p>With the default threshold of 3:</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def run():
    prepare(""action1"")  # Noncompliant - ""action1"" is duplicated 3 times
    execute(""action1"")
    release(""action1"")

@app.route(""/api/users/"", methods=['GET', 'POST', 'PUT'])
def users():
    pass

@app.route(""/api/projects/"", methods=['GET', 'POST', 'PUT'])  # Compliant - strings inside decorators are ignored
def projects():
    pass
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
ACTION_1 = ""action1""

def run():
    prepare(ACTION_1)
    execute(ACTION_1)
    release(ACTION_1)
</pre>",CRITICAL,2min,DISTINCT,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFKATlwiQl6exNNa,c:S3776,Refactor this function to reduce its Cognitive Complexity from 42 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ-I9TlwiQl6exDgk,c:S3687,"Check if the usage of the type ""volatile unsigned int[64]"" is really appropriate here (for inter-thread synchronization, atomic types are more suited).",Local variables and member data should not be volatile,"<h2>Why is this an issue?</h2>
<p>The main intended use-case for <code>volatile</code> in C and C++ is to access data that can be modified by something external to the program,
typically some hardware register. In contrast with some other languages with a <code>volatile</code> keyword, it does not provide any useful
guarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in
kernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.</p>
<p>According to the C standard:</p>
<blockquote>
  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might
  be changed by means undetectable by an implementation.</p>
</blockquote>
<p>Local variables and data members are completely controlled by the C++ language. This means they can’t change their value without the compiler
knowing about it. Therefore, it doesn’t make sense for them to be marked as <code>volatile</code>.</p>
<p>If the intent is to share those variables between threads, race conditions can be avoided by using synchronization primitives (such as
<code>std::mutex</code>) or atomic types (<code>_Atomic</code> in C11, <code>std::atomic&lt;T&gt;</code> in C++11).</p>
<p>This rule raises an issue when a local variable or class data member is declared as <code>volatile</code> (at the top level of the type, pointers
to volatile are not reported).</p>
<h3>Noncompliant code example</h3>
<pre>
volatile int counter; // Noncompliant
User * volatile vpUser; // Noncompliant; pointer is volatile
User volatile * pvUser;  // Compliant; User instance is volatile, not the pointer
</pre>
<h3>Compliant solution</h3>
<pre>
atomic_int counter;
std::atomic&lt;User*&gt; vpUser;
User volatile * pvUser;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive"">CERT CON02-C</a> - Do not
  use volatile as a synchronization primitive </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory"">CP.200: Use
  <code>volatile</code> only to talk to non-C++ memory</a> </li>
  <li> STIG Viewer - <a href=""https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222567"">Application Security and
  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>
</ul>",MAJOR,1h,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['stig-ASD_V5R3:V-222567']
AZHFJ-I9TlwiQl6exDgl,c:S3687,"Check if the usage of the type ""volatile unsigned int"" is really appropriate here (for inter-thread synchronization, atomic types are more suited).",Local variables and member data should not be volatile,"<h2>Why is this an issue?</h2>
<p>The main intended use-case for <code>volatile</code> in C and C++ is to access data that can be modified by something external to the program,
typically some hardware register. In contrast with some other languages with a <code>volatile</code> keyword, it does not provide any useful
guarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in
kernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.</p>
<p>According to the C standard:</p>
<blockquote>
  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might
  be changed by means undetectable by an implementation.</p>
</blockquote>
<p>Local variables and data members are completely controlled by the C++ language. This means they can’t change their value without the compiler
knowing about it. Therefore, it doesn’t make sense for them to be marked as <code>volatile</code>.</p>
<p>If the intent is to share those variables between threads, race conditions can be avoided by using synchronization primitives (such as
<code>std::mutex</code>) or atomic types (<code>_Atomic</code> in C11, <code>std::atomic&lt;T&gt;</code> in C++11).</p>
<p>This rule raises an issue when a local variable or class data member is declared as <code>volatile</code> (at the top level of the type, pointers
to volatile are not reported).</p>
<h3>Noncompliant code example</h3>
<pre>
volatile int counter; // Noncompliant
User * volatile vpUser; // Noncompliant; pointer is volatile
User volatile * pvUser;  // Compliant; User instance is volatile, not the pointer
</pre>
<h3>Compliant solution</h3>
<pre>
atomic_int counter;
std::atomic&lt;User*&gt; vpUser;
User volatile * pvUser;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive"">CERT CON02-C</a> - Do not
  use volatile as a synchronization primitive </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory"">CP.200: Use
  <code>volatile</code> only to talk to non-C++ memory</a> </li>
  <li> STIG Viewer - <a href=""https://stigviewer.com/stig/application_security_and_development/2023-06-08/finding/V-222567"">Application Security and
  Development: V-222567</a> - The application must not be vulnerable to race conditions. </li>
</ul>",MAJOR,1h,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['stig-ASD_V5R3:V-222567']
AZHFJ-HsTlwiQl6exDeW,c:S1820,"Refactor this structure so it has no more than 20 fields, rather than the 22 it currently has.",Structures should not have too many fields,"<h2>Why is this an issue?</h2>
<p>A structure, such as a <code>struct</code>, <code>union</code> or <code>class</code> that grows too much tends to aggregate too many
responsibilities and inevitably becomes harder to understand and therefore to maintain, and having a lot of fields is an indication that a structure
has grown too large.</p>
<p>Above a specific threshold, it is strongly advised to refactor the structure into smaller ones that focus on well defined topics.</p>",MAJOR,1h,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-HsTlwiQl6exDev,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""priv"" is ""struct udc_dwc2_data *const"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-HsTlwiQl6exDew,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""backup"" is ""struct dwc2_reg_backup *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-HsTlwiQl6exDex,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""priv"" is ""struct udc_dwc2_data *const"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-HsTlwiQl6exDey,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""backup"" is ""struct dwc2_reg_backup *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-HsTlwiQl6exDez,c:S3776,Refactor this function to reduce its Cognitive Complexity from 35 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ-HsTlwiQl6exDe0,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBgZTlwiQl6exGVo,c:S1301,"Replace this ""switch"" statement by ""if"" statements to increase readability.","""if"" statements should be preferred over ""switch"" when simpler","<h2>Why is this an issue?</h2>
<p><code>switch</code> statements are useful when there are many different cases depending on the value of the same expression. For just one or two
cases, however, the code will be more readable with <code>if</code> statements.</p>
<p>In particular, <code>if</code> statements are more suitable when the condition of the <code>switch</code> is boolean.</p>
<p>This rule detects statements that could be simplified with a simple <code>if / else</code>. That is when there is at most one <code>case</code>,
not counting those that fall through to a <code>default</code>.</p>
<p>The following code:</p>
<pre>
switch (variable) {
  case 0:
    doSomething();
    break;
  case 1:
  case 2:
  default:
    doSomethingElse();
    break;
}
</pre>
<p>Would be more readable that way:</p>
<pre>
if (variable == 0) {
  doSomething();
} else {
  doSomethingElse();
}
</pre>
<p>While the following snippets don’t trigger the rule because using <code>if</code> would not improve their readability:</p>
<pre>
switch (variable) {
  case 0:
  case 1: // Would need a less readable check in an `if`
    doSomething();
    break;
}

switch (variable) {
  case 0:
    doSomething();
    break;
  case 1: // Would require introducing `else if`
    doSomethingElse();
    break;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBgZTlwiQl6exGVp,c:S1301,"Replace this ""switch"" statement by ""if"" statements to increase readability.","""if"" statements should be preferred over ""switch"" when simpler","<h2>Why is this an issue?</h2>
<p><code>switch</code> statements are useful when there are many different cases depending on the value of the same expression. For just one or two
cases, however, the code will be more readable with <code>if</code> statements.</p>
<p>In particular, <code>if</code> statements are more suitable when the condition of the <code>switch</code> is boolean.</p>
<p>This rule detects statements that could be simplified with a simple <code>if / else</code>. That is when there is at most one <code>case</code>,
not counting those that fall through to a <code>default</code>.</p>
<p>The following code:</p>
<pre>
switch (variable) {
  case 0:
    doSomething();
    break;
  case 1:
  case 2:
  default:
    doSomethingElse();
    break;
}
</pre>
<p>Would be more readable that way:</p>
<pre>
if (variable == 0) {
  doSomething();
} else {
  doSomethingElse();
}
</pre>
<p>While the following snippets don’t trigger the rule because using <code>if</code> would not improve their readability:</p>
<pre>
switch (variable) {
  case 0:
  case 1: // Would need a less readable check in an `if`
    doSomething();
    break;
}

switch (variable) {
  case 0:
    doSomething();
    break;
  case 1: // Would require introducing `else if`
    doSomethingElse();
    break;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGXVTlwiQl6exPGy,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""qos"" is ""struct bt_audio_codec_qos *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKGXVTlwiQl6exPG1,c:S3776,Refactor this function to reduce its Cognitive Complexity from 31 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKGXVTlwiQl6exPG2,c:S1066,"Merge this ""if"" statement with the enclosing one.","Mergeable ""if"" statements should be combined","<h2>Why is this an issue?</h2>
<p>Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as
possible, by avoiding unnecessary nesting, is considered a good practice.</p>
<p>Merging <code>if</code> statements when possible will decrease the nesting of the code and improve its readability.</p>
<p>Code like</p>
<pre>
if (condition1) {
  if (condition2) {             // Noncompliant
    /* ... */
  }
}
</pre>
<p>will be more readable as</p>
<pre>
if (condition1 &amp;&amp; condition2) { // Compliant
  /* ... */
}
</pre>
<h2>How to fix it</h2>
<p>If merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a
better approach to fix readability.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
if (fs::exists(path)) {
  if (fs::is_regular_file(path) || fs::is_directory(path)) { // Noncompliant
    /* ... */
  }
}
</pre>
<h4>Compliant solution</h4>
<pre>
bool isFileOrDirectory(fs::path const&amp; path) {
  return fs::is_regular_file(path) || fs::is_directory(path);
}

/* ... */

if (fs::exists(path) &amp;&amp; isFileOrDirectory(path)) { // Compliant
  /* ... */
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKGXVTlwiQl6exPG3,c:S1066,"Merge this ""if"" statement with the enclosing one.","Mergeable ""if"" statements should be combined","<h2>Why is this an issue?</h2>
<p>Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as
possible, by avoiding unnecessary nesting, is considered a good practice.</p>
<p>Merging <code>if</code> statements when possible will decrease the nesting of the code and improve its readability.</p>
<p>Code like</p>
<pre>
if (condition1) {
  if (condition2) {             // Noncompliant
    /* ... */
  }
}
</pre>
<p>will be more readable as</p>
<pre>
if (condition1 &amp;&amp; condition2) { // Compliant
  /* ... */
}
</pre>
<h2>How to fix it</h2>
<p>If merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a
better approach to fix readability.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
if (fs::exists(path)) {
  if (fs::is_regular_file(path) || fs::is_directory(path)) { // Noncompliant
    /* ... */
  }
}
</pre>
<h4>Compliant solution</h4>
<pre>
bool isFileOrDirectory(fs::path const&amp; path) {
  return fs::is_regular_file(path) || fs::is_directory(path);
}

/* ... */

if (fs::exists(path) &amp;&amp; isFileOrDirectory(path)) { // Compliant
  /* ... */
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKGBzTlwiQl6exOVG,c:S3776,Refactor this function to reduce its Cognitive Complexity from 134 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKGfQTlwiQl6exPPQ,c:S3776,Refactor this function to reduce its Cognitive Complexity from 27 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ_qfTlwiQl6exEmE,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""data"" is ""struct gpio_stepper_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ_qfTlwiQl6exEmF,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""data"" is ""struct gpio_stepper_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ_qfTlwiQl6exEmG,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""data"" is ""struct gpio_stepper_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBHxTlwiQl6exF92,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""f"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBHxTlwiQl6exF93,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""fixture"" is ""struct stepper_fixture *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKIL8TlwiQl6exQ0l,python:S3776,Refactor this function to reduce its Cognitive Complexity from 19 to the 15 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 5.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def process_eligible_users(users):
    for user in users:             # +1 (for)
        if ((user.is_active and    # +1 (if) +1 (nested) +1 (multiple conditions)
            user.has_profile) or   # +1 (mixed operator)
            user.age &gt; 18 ):
            user.process()
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>process_eligible_users</code> function, which now only has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def process_eligible_users(users):
    for user in users:             # +1 (for)
        if is_eligible_user(user): # +1 (if) +1 (nested)
            user.process()

def is_eligible_user(user):
    return ((user.is_active and user.has_profile) or user.age &gt; 18) # +1 (multiple conditions) +1 (mixed operators)
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p><em>Note:</em> The code is simplified here, to illustrate the purpose. Please imagine there is more happening in the process.<br></p>
<p>The bellow code has a cognitive complexity score of 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
def process_user(user):
    if user.is_active():             # +1 (if)
        if user.has_profile():       # +1 (if) +1 (nested)
            ... # process active user with profile
        else:                        # +1 (else)
            ... # process active user without profile
    else:                            # +1 (else)
        if user.has_profile():       # +1 (if) +1 (nested)
            ... # process inactive user with profile
        else:                        # +1 (else)
            ... # process inactive user without profile
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions and the breaks in flow are no more
nested.<br> The <code>process_user</code> has now a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
def process_user(user):
    if user.is_active():             # +1 (if)
        process_active_user(user)
    else:                            # +1 (else)
        process_inactive_user(user)

def process_active_user(user):
    if user.has_profile():           # +1 (if) +1 (nested)
        ... # process active user with profile
    else:                            # +1 (else)
        ... # process active user without profile

def process_inactive_user(user):
    if user.has_profile():           # +1 (if) +1 (nested)
        ... # process inactive user with profile
    else:                            # +1 (else)
        ... # process inactive user without profile
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 6.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
def calculate(data):
    if data is not None:  # +1 (if)
        total = 0
        for item in data: # +1 (for) +1 (nested)
            if item &gt; 0:  # +1 (if)  +2 (nested)
                total += item * 2
        return total
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 4.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
def calculate(data):
    if data is None:      # +1 (if)
        return None
    total = 0
    for item in data:     # +1 (for)
        if item &gt; 0:      # +1 (if) +1 (nested)
            total += item * 2
    return total
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFjzTlwiQl6exNtZ,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFbYTlwiQl6exNjH,c:S912,Remove any side effects from right hand operands of logical && operator.,The right-hand operands of && and || should not contain side effects,"<h2>Why is this an issue?</h2>
<p>There are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those
side effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are
<code>&amp;&amp;</code> and <code>||</code>, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The
conditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect
occurring.</p>
<p>Operations that cause side effects are:</p>
<ul>
  <li> accessing a volatile object </li>
  <li> modifying an object </li>
  <li> modifying a file </li>
  <li> calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. </li>
</ul>
<p>This rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.</p>
<h3>Noncompliant code example</h3>
<pre>
if ( ishigh &amp;&amp; ( x == i++ ) ) // Noncompliant
...
if ( ishigh &amp;&amp; ( x ==  getX() ) ) // Only acceptable if getX() is known to have no side effects
</pre>
<p>The operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function</p>
<p>that does any of those operations, which cause changes in the state of the execution environment of the calling function.</p>
<p>For the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.</p>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 12.4 - The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C++:2008, 5-14-1 - The right hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C:2012, 13.5 - The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/vdUxBQ"">CERT, EXP02-C.</a> - Be aware of the short-circuit behavior of the logical AND and OR
  operators </li>
</ul>",BLOCKER,15min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFbYTlwiQl6exNjN,c:S912,Remove any side effects from right hand operands of logical && operator.,The right-hand operands of && and || should not contain side effects,"<h2>Why is this an issue?</h2>
<p>There are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those
side effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are
<code>&amp;&amp;</code> and <code>||</code>, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The
conditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect
occurring.</p>
<p>Operations that cause side effects are:</p>
<ul>
  <li> accessing a volatile object </li>
  <li> modifying an object </li>
  <li> modifying a file </li>
  <li> calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. </li>
</ul>
<p>This rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.</p>
<h3>Noncompliant code example</h3>
<pre>
if ( ishigh &amp;&amp; ( x == i++ ) ) // Noncompliant
...
if ( ishigh &amp;&amp; ( x ==  getX() ) ) // Only acceptable if getX() is known to have no side effects
</pre>
<p>The operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function</p>
<p>that does any of those operations, which cause changes in the state of the execution environment of the calling function.</p>
<p>For the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.</p>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 12.4 - The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C++:2008, 5-14-1 - The right hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C:2012, 13.5 - The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/vdUxBQ"">CERT, EXP02-C.</a> - Be aware of the short-circuit behavior of the logical AND and OR
  operators </li>
</ul>",BLOCKER,15min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFbYTlwiQl6exNjU,c:S912,Remove any side effects from right hand operands of logical && operator.,The right-hand operands of && and || should not contain side effects,"<h2>Why is this an issue?</h2>
<p>There are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those
side effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are
<code>&amp;&amp;</code> and <code>||</code>, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The
conditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect
occurring.</p>
<p>Operations that cause side effects are:</p>
<ul>
  <li> accessing a volatile object </li>
  <li> modifying an object </li>
  <li> modifying a file </li>
  <li> calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. </li>
</ul>
<p>This rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.</p>
<h3>Noncompliant code example</h3>
<pre>
if ( ishigh &amp;&amp; ( x == i++ ) ) // Noncompliant
...
if ( ishigh &amp;&amp; ( x ==  getX() ) ) // Only acceptable if getX() is known to have no side effects
</pre>
<p>The operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function</p>
<p>that does any of those operations, which cause changes in the state of the execution environment of the calling function.</p>
<p>For the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.</p>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 12.4 - The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C++:2008, 5-14-1 - The right hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C:2012, 13.5 - The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/vdUxBQ"">CERT, EXP02-C.</a> - Be aware of the short-circuit behavior of the logical AND and OR
  operators </li>
</ul>",BLOCKER,15min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFbYTlwiQl6exNjb,c:S912,Remove any side effects from right hand operands of logical && operator.,The right-hand operands of && and || should not contain side effects,"<h2>Why is this an issue?</h2>
<p>There are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those
side effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are
<code>&amp;&amp;</code> and <code>||</code>, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The
conditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect
occurring.</p>
<p>Operations that cause side effects are:</p>
<ul>
  <li> accessing a volatile object </li>
  <li> modifying an object </li>
  <li> modifying a file </li>
  <li> calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. </li>
</ul>
<p>This rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.</p>
<h3>Noncompliant code example</h3>
<pre>
if ( ishigh &amp;&amp; ( x == i++ ) ) // Noncompliant
...
if ( ishigh &amp;&amp; ( x ==  getX() ) ) // Only acceptable if getX() is known to have no side effects
</pre>
<p>The operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function</p>
<p>that does any of those operations, which cause changes in the state of the execution environment of the calling function.</p>
<p>For the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.</p>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 12.4 - The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C++:2008, 5-14-1 - The right hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C:2012, 13.5 - The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/vdUxBQ"">CERT, EXP02-C.</a> - Be aware of the short-circuit behavior of the logical AND and OR
  operators </li>
</ul>",BLOCKER,15min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFbYTlwiQl6exNjc,c:S912,Remove any side effects from right hand operands of logical && operator.,The right-hand operands of && and || should not contain side effects,"<h2>Why is this an issue?</h2>
<p>There are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those
side effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are
<code>&amp;&amp;</code> and <code>||</code>, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The
conditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect
occurring.</p>
<p>Operations that cause side effects are:</p>
<ul>
  <li> accessing a volatile object </li>
  <li> modifying an object </li>
  <li> modifying a file </li>
  <li> calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. </li>
</ul>
<p>This rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.</p>
<h3>Noncompliant code example</h3>
<pre>
if ( ishigh &amp;&amp; ( x == i++ ) ) // Noncompliant
...
if ( ishigh &amp;&amp; ( x ==  getX() ) ) // Only acceptable if getX() is known to have no side effects
</pre>
<p>The operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function</p>
<p>that does any of those operations, which cause changes in the state of the execution environment of the calling function.</p>
<p>For the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.</p>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 12.4 - The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C++:2008, 5-14-1 - The right hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C:2012, 13.5 - The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/vdUxBQ"">CERT, EXP02-C.</a> - Be aware of the short-circuit behavior of the logical AND and OR
  operators </li>
</ul>",BLOCKER,15min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFbYTlwiQl6exNjV,c:S912,Remove any side effects from right hand operands of logical || operator.,The right-hand operands of && and || should not contain side effects,"<h2>Why is this an issue?</h2>
<p>There are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those
side effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are
<code>&amp;&amp;</code> and <code>||</code>, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The
conditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect
occurring.</p>
<p>Operations that cause side effects are:</p>
<ul>
  <li> accessing a volatile object </li>
  <li> modifying an object </li>
  <li> modifying a file </li>
  <li> calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. </li>
</ul>
<p>This rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.</p>
<h3>Noncompliant code example</h3>
<pre>
if ( ishigh &amp;&amp; ( x == i++ ) ) // Noncompliant
...
if ( ishigh &amp;&amp; ( x ==  getX() ) ) // Only acceptable if getX() is known to have no side effects
</pre>
<p>The operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function</p>
<p>that does any of those operations, which cause changes in the state of the execution environment of the calling function.</p>
<p>For the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.</p>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 12.4 - The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C++:2008, 5-14-1 - The right hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>
  <li> MISRA C:2012, 13.5 - The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/vdUxBQ"">CERT, EXP02-C.</a> - Be aware of the short-circuit behavior of the logical AND and OR
  operators </li>
</ul>",BLOCKER,15min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFbYTlwiQl6exNjf,c:S3491,"Remove this useless sequence of pointer operators: ""*&"".",Redundant pointer operator sequences should be removed,"<h2>Why is this an issue?</h2>
<p>By contract, chaining the 'Address of' operator <code>&amp;</code> with the 'Indirection' operator <code>*</code> results in a return to the
initial value. Thus, such combinations are confusing at best, and bugs at worst.</p>
<h3>Noncompliant code example</h3>
<pre>
int *ptr = ...;
int *result1 = &amp;(*ptr); //Noncompliant
int *result2 = &amp;*ptr; //Noncompliant

int value = 4;
int result3 = *(&amp;value); //Noncompliant
int result4 = *&amp;value; //Noncompliant
</pre>
<h3>Compliant solution</h3>
<pre>
int *ptr = ...;
int *result1 = ptr;
int *result2 = ptr;

int value = 4;
int result3 = value;
int result4 = value;
</pre>
<h3>Exceptions</h3>
<p>No issue is raised when the <code>*</code> or <code>&amp;</code> operators are overloaded or when both operators are not located in the same piece
of code (one being generated by a macro expansion and the other one located in the main source code for instance).</p>",BLOCKER,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFfgTlwiQl6exNoK,c:S3776,Refactor this function to reduce its Cognitive Complexity from 27 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFfgTlwiQl6exNoL,c:S3358,Extract this nested conditional operator into an independent statement.,Conditional operators should not be nested,"<h2>Why is this an issue?</h2>
<p>Nested ternaries are hard to read and can make the order of operations complex to understand.</p>
<pre>
int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Noncompliant
}
</pre>
<p>Instead, use another line to express the nested operation in a separate statement.</p>
<pre>
int max(int p1, int p2, int p3) {
  if (p1 &gt; p2) {
    return p1 &gt; p3 ? p1 : p3;
  } else {
    return p2 &gt; p3 ? p2 : p3;
  }
}
</pre>
<h3>Exceptions</h3>
<p>In C++11, the rule ignores ternary operators inside <code>constexpr</code> functions.</p>
<p>Indeed, in C++11, such functions are limited to just a return statement, so using a ternary operator might be required. Later standards lifted this
restriction, so this exception does not apply to them.</p>
<pre>
constexpr int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Compliant by exception in C++11
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKFfgTlwiQl6exNoM,c:S3358,Extract this nested conditional operator into an independent statement.,Conditional operators should not be nested,"<h2>Why is this an issue?</h2>
<p>Nested ternaries are hard to read and can make the order of operations complex to understand.</p>
<pre>
int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Noncompliant
}
</pre>
<p>Instead, use another line to express the nested operation in a separate statement.</p>
<pre>
int max(int p1, int p2, int p3) {
  if (p1 &gt; p2) {
    return p1 &gt; p3 ? p1 : p3;
  } else {
    return p2 &gt; p3 ? p2 : p3;
  }
}
</pre>
<h3>Exceptions</h3>
<p>In C++11, the rule ignores ternary operators inside <code>constexpr</code> functions.</p>
<p>Indeed, in C++11, such functions are limited to just a return statement, so using a ternary operator might be required. Later standards lifted this
restriction, so this exception does not apply to them.</p>
<pre>
constexpr int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Compliant by exception in C++11
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKFfgTlwiQl6exNoN,c:S3358,Extract this nested conditional operator into an independent statement.,Conditional operators should not be nested,"<h2>Why is this an issue?</h2>
<p>Nested ternaries are hard to read and can make the order of operations complex to understand.</p>
<pre>
int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Noncompliant
}
</pre>
<p>Instead, use another line to express the nested operation in a separate statement.</p>
<pre>
int max(int p1, int p2, int p3) {
  if (p1 &gt; p2) {
    return p1 &gt; p3 ? p1 : p3;
  } else {
    return p2 &gt; p3 ? p2 : p3;
  }
}
</pre>
<h3>Exceptions</h3>
<p>In C++11, the rule ignores ternary operators inside <code>constexpr</code> functions.</p>
<p>Indeed, in C++11, such functions are limited to just a return statement, so using a ternary operator might be required. Later standards lifted this
restriction, so this exception does not apply to them.</p>
<pre>
constexpr int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Compliant by exception in C++11
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKFfgTlwiQl6exNoO,c:S3358,Extract this nested conditional operator into an independent statement.,Conditional operators should not be nested,"<h2>Why is this an issue?</h2>
<p>Nested ternaries are hard to read and can make the order of operations complex to understand.</p>
<pre>
int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Noncompliant
}
</pre>
<p>Instead, use another line to express the nested operation in a separate statement.</p>
<pre>
int max(int p1, int p2, int p3) {
  if (p1 &gt; p2) {
    return p1 &gt; p3 ? p1 : p3;
  } else {
    return p2 &gt; p3 ? p2 : p3;
  }
}
</pre>
<h3>Exceptions</h3>
<p>In C++11, the rule ignores ternary operators inside <code>constexpr</code> functions.</p>
<p>Indeed, in C++11, such functions are limited to just a return statement, so using a ternary operator might be required. Later standards lifted this
restriction, so this exception does not apply to them.</p>
<pre>
constexpr int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Compliant by exception in C++11
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKFfgTlwiQl6exNoP,c:S3358,Extract this nested conditional operator into an independent statement.,Conditional operators should not be nested,"<h2>Why is this an issue?</h2>
<p>Nested ternaries are hard to read and can make the order of operations complex to understand.</p>
<pre>
int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Noncompliant
}
</pre>
<p>Instead, use another line to express the nested operation in a separate statement.</p>
<pre>
int max(int p1, int p2, int p3) {
  if (p1 &gt; p2) {
    return p1 &gt; p3 ? p1 : p3;
  } else {
    return p2 &gt; p3 ? p2 : p3;
  }
}
</pre>
<h3>Exceptions</h3>
<p>In C++11, the rule ignores ternary operators inside <code>constexpr</code> functions.</p>
<p>Indeed, in C++11, such functions are limited to just a return statement, so using a ternary operator might be required. Later standards lifted this
restriction, so this exception does not apply to them.</p>
<pre>
constexpr int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Compliant by exception in C++11
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKFfgTlwiQl6exNoQ,c:S3358,Extract this nested conditional operator into an independent statement.,Conditional operators should not be nested,"<h2>Why is this an issue?</h2>
<p>Nested ternaries are hard to read and can make the order of operations complex to understand.</p>
<pre>
int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Noncompliant
}
</pre>
<p>Instead, use another line to express the nested operation in a separate statement.</p>
<pre>
int max(int p1, int p2, int p3) {
  if (p1 &gt; p2) {
    return p1 &gt; p3 ? p1 : p3;
  } else {
    return p2 &gt; p3 ? p2 : p3;
  }
}
</pre>
<h3>Exceptions</h3>
<p>In C++11, the rule ignores ternary operators inside <code>constexpr</code> functions.</p>
<p>Indeed, in C++11, such functions are limited to just a return statement, so using a ternary operator might be required. Later standards lifted this
restriction, so this exception does not apply to them.</p>
<pre>
constexpr int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Compliant by exception in C++11
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKFfgTlwiQl6exNoR,c:S3358,Extract this nested conditional operator into an independent statement.,Conditional operators should not be nested,"<h2>Why is this an issue?</h2>
<p>Nested ternaries are hard to read and can make the order of operations complex to understand.</p>
<pre>
int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Noncompliant
}
</pre>
<p>Instead, use another line to express the nested operation in a separate statement.</p>
<pre>
int max(int p1, int p2, int p3) {
  if (p1 &gt; p2) {
    return p1 &gt; p3 ? p1 : p3;
  } else {
    return p2 &gt; p3 ? p2 : p3;
  }
}
</pre>
<h3>Exceptions</h3>
<p>In C++11, the rule ignores ternary operators inside <code>constexpr</code> functions.</p>
<p>Indeed, in C++11, such functions are limited to just a return statement, so using a ternary operator might be required. Later standards lifted this
restriction, so this exception does not apply to them.</p>
<pre>
constexpr int max(int p1, int p2, int p3) {
  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Compliant by exception in C++11
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKHCaTlwiQl6exP90,c:S5955,"Declare the variable ""i"" inside the loop.",Loop variables should be declared in the minimal possible scope,"<h2>Why is this an issue?</h2>
<p>When a loop variable is not used outside of a loop, it should be declared inside the loop declaration:</p>
<ul>
  <li> It improves readability. The scope of the variable is clearly defined. </li>
  <li> It reduces the number of mistakes. The variable can’t be accidentally misused outside of the loop. </li>
  <li> Resources are not retained longer than necessary. </li>
</ul>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void f() {
  int i = 0; // Noncompliant: i is not used outside of the loop
  for (i = 0; i &lt; 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; std::endl;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void f() {
  for (int i = 0; i &lt; 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; std::endl;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es5-keep-scopes-small"">ES.5: Keep
  scopes small</a> </li>
</ul>",MINOR,5min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKHCaTlwiQl6exP92,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""ext"" is ""struct llext *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKHCaTlwiQl6exP91,c:S5955,"Declare the variable ""i"" inside the loop.",Loop variables should be declared in the minimal possible scope,"<h2>Why is this an issue?</h2>
<p>When a loop variable is not used outside of a loop, it should be declared inside the loop declaration:</p>
<ul>
  <li> It improves readability. The scope of the variable is clearly defined. </li>
  <li> It reduces the number of mistakes. The variable can’t be accidentally misused outside of the loop. </li>
  <li> Resources are not retained longer than necessary. </li>
</ul>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void f() {
  int i = 0; // Noncompliant: i is not used outside of the loop
  for (i = 0; i &lt; 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; std::endl;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void f() {
  for (int i = 0; i &lt; 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; std::endl;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es5-keep-scopes-small"">ES.5: Keep
  scopes small</a> </li>
</ul>",MINOR,5min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKHCaTlwiQl6exP93,c:S3776,Refactor this function to reduce its Cognitive Complexity from 36 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKHCaTlwiQl6exP94,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKHCaTlwiQl6exP98,c:S3776,Refactor this function to reduce its Cognitive Complexity from 65 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKHCaTlwiQl6exP9-,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKHCETlwiQl6exP9B,c:S3776,Refactor this function to reduce its Cognitive Complexity from 59 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKG0LTlwiQl6exPte,c:S3776,Refactor this function to reduce its Cognitive Complexity from 40 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKF8STlwiQl6exOL2,c:S1134,"Take the required action to fix the issue indicated by this ""FIXME"" comment.","Track uses of ""FIXME"" tags","<h2>Why is this an issue?</h2>
<p><code>FIXME</code> tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.</p>
<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>
<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>
<pre>
int Divide(int numerator, int denominator)
{
    return numerator / denominator; // FIXME denominator value might be 0
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/546"">CWE-546 - Suspicious Comment</a> </li>
</ul>",MAJOR,0min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:546']
AZHFKF8STlwiQl6exOL5,c:S824,"Move this function declaration outside of this block scope, or if the intent was to declare a variable, use a syntax that avoids the most vexing parse.",Functions should not be declared at block scope,"<h2>Why is this an issue?</h2>
<p>It is rarely useful to declare a function at block scope. Such a function will not get special access to any name in its enclosing scope, and
therefore, it is equivalent but clearer to declare it instead in the enclosing namespace.</p>
<p>Additionally, when a function is declared at block scope, the intent is often not to declare a function but instead to declare and initialize a
variable. This problem is nicknamed the <em>most vexing parse</em> and stems from the fact that some syntaxes can be ambiguous, and that in that case
the language unintuitively favors function declaration:</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void f() {
  int a;
  string b();
  short c(short (a));
}
</pre>
<ul>
  <li> <code>b</code> could be interpreted as:
    <ul>
      <li> A variable of type <code>string</code> with empty initialization or </li>
      <li> A function with no argument and returning a <code>string</code>. </li>
    </ul>   The second interpretation is selected.  </li>
  <li> Similarly, <code>c</code> could be interpreted as:
    <ul>
      <li> A variable of type <code>short</code> initialized with the value <code>a</code> converted to <code>short</code> or </li>
      <li> A function that takes a parameter named <code>a</code> (with extra parentheses) of type <code>short</code> and returning a
      <code>short</code> </li>
    </ul>   Here again, the second interpretation is selected.  </li>
</ul>
<p>There are several ways to write the code differently so that <code>b</code> and <code>c</code> can only be interpreted as variables. For
instance:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void f() {
  int a;
  string b {};
  auto c = short (a);
}
</pre>
<p>By raising issues on local function declaration, this rule helps detect when a function is inadvertently declared.</p>
<h2>How to fix it</h2>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
class A {
};

void fun() {
  void nestedFun();  // Noncompliant; declares a function in block scope

  A a();      // Noncompliant; declares a function at block scope, not an object
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
class A {
};

void nestedFun(); // Compliant, function declaration moved outside of fun

void fun() {
  A a;      // Compliant; declares an object
}
</pre>
<h2>Resources</h2>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2023, 6.0.1 - Block scope declarations shall not be visually ambiguous </li>
  <li> MISRA C++:2008, 3-1-2 - Functions shall not be declared at block scope </li>
  <li> MISRA C:2004, 8.6 - Functions shall be declared at file scope </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKF8STlwiQl6exOL3,c:S1135,"Complete the task associated to this ""TODO"" comment.","Track uses of ""TODO"" tags","<h2>Why is this an issue?</h2>
<p>Developers often use <code>TODO</code> tags to mark areas in the code where additional work or improvements are needed but are not implemented
immediately. However, these <code>TODO</code> tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to
identify and address unattended <code>TODO</code> tags to ensure a clean and maintainable codebase. This description explores why this is a problem
and how it can be fixed to improve the overall code quality.</p>
<h3>What is the potential impact?</h3>
<p>Unattended <code>TODO</code> tags in code can have significant implications for the development process and the overall codebase.</p>
<p>Incomplete Functionality: When developers leave <code>TODO</code> tags without implementing the corresponding code, it results in incomplete
functionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.</p>
<p>Missed Bug Fixes: If developers do not promptly address <code>TODO</code> tags, they might overlook critical bug fixes and security updates.
Delayed bug fixes can result in more severe issues and increase the effort required to resolve them later.</p>
<p>Impact on Collaboration: In team-based development environments, unattended <code>TODO</code> tags can hinder collaboration. Other team members
might not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.</p>
<p>Codebase Bloat: The accumulation of unattended <code>TODO</code> tags over time can clutter the codebase and make it difficult to distinguish
between work in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.</p>
<p>Addressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among
developers.</p>
<h3>Noncompliant code example</h3>
<pre>
void foo() {
  // TODO
}
</pre>
<h2>Resources</h2>
<ul>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/546"">CWE-546 - Suspicious Comment</a> </li>
</ul>",INFO,0min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",['cwe:546']
AZHFKF8STlwiQl6exOL4,c:S1135,"Complete the task associated to this ""TODO"" comment.","Track uses of ""TODO"" tags","<h2>Why is this an issue?</h2>
<p>Developers often use <code>TODO</code> tags to mark areas in the code where additional work or improvements are needed but are not implemented
immediately. However, these <code>TODO</code> tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to
identify and address unattended <code>TODO</code> tags to ensure a clean and maintainable codebase. This description explores why this is a problem
and how it can be fixed to improve the overall code quality.</p>
<h3>What is the potential impact?</h3>
<p>Unattended <code>TODO</code> tags in code can have significant implications for the development process and the overall codebase.</p>
<p>Incomplete Functionality: When developers leave <code>TODO</code> tags without implementing the corresponding code, it results in incomplete
functionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.</p>
<p>Missed Bug Fixes: If developers do not promptly address <code>TODO</code> tags, they might overlook critical bug fixes and security updates.
Delayed bug fixes can result in more severe issues and increase the effort required to resolve them later.</p>
<p>Impact on Collaboration: In team-based development environments, unattended <code>TODO</code> tags can hinder collaboration. Other team members
might not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.</p>
<p>Codebase Bloat: The accumulation of unattended <code>TODO</code> tags over time can clutter the codebase and make it difficult to distinguish
between work in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.</p>
<p>Addressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among
developers.</p>
<h3>Noncompliant code example</h3>
<pre>
void foo() {
  // TODO
}
</pre>
<h2>Resources</h2>
<ul>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/546"">CWE-546 - Suspicious Comment</a> </li>
</ul>",INFO,0min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",['cwe:546']
AZHFKF8STlwiQl6exOL6,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKF8STlwiQl6exOL7,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKF7hTlwiQl6exOK2,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKF7hTlwiQl6exOK3,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKF7hTlwiQl6exOK5,c:S125,Remove the commented out code.,Sections of code should not be commented out,"<h2>Why is this an issue?</h2>
<p>Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.</p>
<p>Commented-out code should be deleted and can be retrieved from source control history if required.</p>
<h3>Exceptions</h3>
<p>This rule does not apply to code documentation using Doxygen, QDoc, markdown, or HTML tags.</p>
<h2>Resources</h2>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 2.4 - Sections of code should not be ""commented out"". </li>
  <li> MISRA C++:2008, 2-7-2 - Sections of code shall not be ""commented out"" using C-style comments. </li>
  <li> MISRA C++:2008, 2-7-3 - Sections of code should not be ""commented out"" using C++ comments. </li>
  <li> MISRA C:2012, Dir. 4.4 - Sections of code should not be ""commented out"" </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKF7NTlwiQl6exOKf,c:S959,Remove this #undef directive.,"""#undef"" should be used with caution","<h2>Why is this an issue?</h2>
<p>Code that contains many macros becomes hard to understand. This is even worse when the set of defined macros is not stable, and you have to know at
each point what macros are defined. Therefore, <code>#undef</code> can decrease the readability of macros.</p>
<p>However, well-disciplined use of <code>#undef</code> can also improve readability, for instance when defining a macro with a limited scope: The
macro is <code>#defined</code>, used a couple of times to reduce code duplication, then immediately <code>#undefed</code>.</p>
<p>This rule raises an issue when a <code>#undef</code> undefines a macro that was defined in another file. It will also raise an issue for an
<code>#undef</code> directive that tries to undefine a non-existing macro.</p>
<h3>Noncompliant code example</h3>
<pre>
#ifndef MY_HDR
#define MY_HDR
#endif
...
#undef MY_HDR    /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#define LEVEL(i) int const i = #i
LEVEL(Debug);
LEVEL(Warning);
LEVEL(Error);
#undef LEVEL
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.6 - #undef shall not be used. </li>
  <li> MISRA C++:2008, 16-0-3 - #undef shall not be used. </li>
  <li> MISRA C:2012, 20.5 - #undef should not be used </li>
</ul>",CRITICAL,2h,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKGI1TlwiQl6exOiq,c:S1134,"Take the required action to fix the issue indicated by this ""FIXME"" comment.","Track uses of ""FIXME"" tags","<h2>Why is this an issue?</h2>
<p><code>FIXME</code> tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.</p>
<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>
<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>
<pre>
int Divide(int numerator, int denominator)
{
    return numerator / denominator; // FIXME denominator value might be 0
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/546"">CWE-546 - Suspicious Comment</a> </li>
</ul>",MAJOR,0min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:546']
AZHFKIKOTlwiQl6exQyx,python:S3776,Refactor this function to reduce its Cognitive Complexity from 21 to the 15 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 5.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def process_eligible_users(users):
    for user in users:             # +1 (for)
        if ((user.is_active and    # +1 (if) +1 (nested) +1 (multiple conditions)
            user.has_profile) or   # +1 (mixed operator)
            user.age &gt; 18 ):
            user.process()
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>process_eligible_users</code> function, which now only has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def process_eligible_users(users):
    for user in users:             # +1 (for)
        if is_eligible_user(user): # +1 (if) +1 (nested)
            user.process()

def is_eligible_user(user):
    return ((user.is_active and user.has_profile) or user.age &gt; 18) # +1 (multiple conditions) +1 (mixed operators)
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p><em>Note:</em> The code is simplified here, to illustrate the purpose. Please imagine there is more happening in the process.<br></p>
<p>The bellow code has a cognitive complexity score of 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
def process_user(user):
    if user.is_active():             # +1 (if)
        if user.has_profile():       # +1 (if) +1 (nested)
            ... # process active user with profile
        else:                        # +1 (else)
            ... # process active user without profile
    else:                            # +1 (else)
        if user.has_profile():       # +1 (if) +1 (nested)
            ... # process inactive user with profile
        else:                        # +1 (else)
            ... # process inactive user without profile
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions and the breaks in flow are no more
nested.<br> The <code>process_user</code> has now a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
def process_user(user):
    if user.is_active():             # +1 (if)
        process_active_user(user)
    else:                            # +1 (else)
        process_inactive_user(user)

def process_active_user(user):
    if user.has_profile():           # +1 (if) +1 (nested)
        ... # process active user with profile
    else:                            # +1 (else)
        ... # process active user without profile

def process_inactive_user(user):
    if user.has_profile():           # +1 (if) +1 (nested)
        ... # process inactive user with profile
    else:                            # +1 (else)
        ... # process inactive user without profile
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 6.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
def calculate(data):
    if data is not None:  # +1 (if)
        total = 0
        for item in data: # +1 (for) +1 (nested)
            if item &gt; 0:  # +1 (if)  +2 (nested)
                total += item * 2
        return total
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 4.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
def calculate(data):
    if data is None:      # +1 (if)
        return None
    total = 0
    for item in data:     # +1 (for)
        if item &gt; 0:      # +1 (if) +1 (nested)
            total += item * 2
    return total
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ7mtTlwiQl6exCHt,c:S1301,"Replace this ""switch"" statement by ""if"" statements to increase readability.","""if"" statements should be preferred over ""switch"" when simpler","<h2>Why is this an issue?</h2>
<p><code>switch</code> statements are useful when there are many different cases depending on the value of the same expression. For just one or two
cases, however, the code will be more readable with <code>if</code> statements.</p>
<p>In particular, <code>if</code> statements are more suitable when the condition of the <code>switch</code> is boolean.</p>
<p>This rule detects statements that could be simplified with a simple <code>if / else</code>. That is when there is at most one <code>case</code>,
not counting those that fall through to a <code>default</code>.</p>
<p>The following code:</p>
<pre>
switch (variable) {
  case 0:
    doSomething();
    break;
  case 1:
  case 2:
  default:
    doSomethingElse();
    break;
}
</pre>
<p>Would be more readable that way:</p>
<pre>
if (variable == 0) {
  doSomething();
} else {
  doSomethingElse();
}
</pre>
<p>While the following snippets don’t trigger the rule because using <code>if</code> would not improve their readability:</p>
<pre>
switch (variable) {
  case 0:
  case 1: // Would need a less readable check in an `if`
    doSomething();
    break;
}

switch (variable) {
  case 0:
    doSomething();
    break;
  case 1: // Would require introducing `else if`
    doSomethingElse();
    break;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ7mtTlwiQl6exCHu,c:S1172,"Remove the unused parameter ""chan"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ7mtTlwiQl6exCHv,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""cal"" is ""struct bmp180_cal_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ7mtTlwiQl6exCHw,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""data"" is ""struct bmp180_data *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ7mtTlwiQl6exCHx,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""cal"" is ""struct bmp180_cal_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ7mtTlwiQl6exCHy,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ7mtTlwiQl6exCHz,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ7mtTlwiQl6exCH0,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ7mtTlwiQl6exCH1,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ7mtTlwiQl6exCH2,c:S1172,"Remove the unused parameter ""action"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKITNTlwiQl6exQ4r,python:S3358,Extract this nested conditional expression into an independent statement.,Conditional expressions should not be nested,"<h2>Why is this an issue?</h2>
<p>Nested conditionals are hard to read and can make the order of operations complex to understand.</p>
<pre>
class Job:
    @property
    def readable_status(self):
        return ""Running"" if job.is_running else ""Failed"" if job.errors else ""Succeeded""  # Noncompliant
</pre>
<p>Instead, use another line to express the nested operation in a separate statement.</p>
<pre>
class Job:
    @property
    def readable_status(self):
        if job.is_running:
            return ""Running""
        return ""Failed"" if job.errors else ""Succeeded""
</pre>
<h3>Exceptions</h3>
<p>No issue is raised on conditional expressions in comprehensions.</p>
<pre>
job_statuses = [""Running"" if job.is_running else ""Failed"" if job.errors else ""Succeeded"" for job in jobs]  # Compliant by exception
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKD52TlwiQl6exMF-,cpp:S5205,"Replace this function pointer with a template parameter or a ""std::function"".",Function pointers should not be used as function parameters,"<h2>Why is this an issue?</h2>
<p>When you want to receive a function as a parameter in a function definition, there are three ways to declare its parameter type:</p>
<ul>
  <li> A function pointer:<br> <code>void f(void (*callback)());</code> </li>
  <li> A typed-erased function wrapper such as <code>std::function</code>:<br> <code>void f(std::function&lt;void()&gt; callback);</code> </li>
  <li> A template parameter:<br> <code>template &lt;class Callback&gt; void f(Callback callback);</code> </li>
</ul>
<p>Using a function pointer is an inferior solution for the following reasons:</p>
<ul>
  <li> Only a function pointer can be passed as an argument, while the other options offer the caller more flexibility because they can take more
  advanced functors, such as lambdas with some captured state </li>
  <li> The syntax is obscure </li>
  <li> It typically has worse performance than the template parameter solution. </li>
</ul>
<p>See {rule:cpp:S5213} for a discussion on choosing between <code>std::function</code> and a template parameter.</p>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
using Criterion = bool (*)(DataPoint const&amp;);
void filter(DataSet&amp; data, Criterion criterion); // Noncompliant

using Callback = void (*)(EventInfo const&amp;);
class Button {
public:
  void addOnClick(Callback c) { // Noncompliant
    myOnClickHandler = c;
  }

private:
  Callback myOnClickHandler;
};
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
template &lt;class Criterion&gt; // Compliant, uses the more efficient template argument
void filter(DataSet&amp; data, Criterion criterion);

using Callback = std::function&lt;void(EventInfo const&amp;)&gt;;
class Button {
public:
  void addOnClick(Callback c) { // Compliant, uses the more flexible std::function
    myOnClickHandler = std::move(c);
  }

private:
  Callback myOnClickHandler;
};
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> C++ reference - <a href=""https://en.cppreference.com/w/cpp/utility/functional/function""><code>std::function</code></a> </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t40-use-function-objects-to-pass-operations-to-algorithms"">T.40:
  Use function objects to pass operations to algorithms</a> </li>
</ul>
<h3>Related rules</h3>
<ul>
  <li> {rule:cpp:S5213} Template parameters should be preferred to ""std::function"" when configuring behavior at compile time </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKD52TlwiQl6exMGf,cpp:S5008,"Replace this use of ""void *"" with a more meaningful type.","""void *"" should not be used in typedefs, member variables, function parameters or return type","<h2>Why is this an issue?</h2>
<p><code>void*</code> is a pointer to memory of unknown type, and therefore works outside of the safety net provided by the type system. While it can
be useful in a function body to interface with external code, there is no good reason to step out of the robust C++ type system when defining a
function, either for the function parameters, or for the function return type. For the same reasons, having a member variable of type
<code>void*</code> is not recommended.</p>
<p>If you want to work with raw memory buffer, use <code>unsigned char *</code> (or <code>byte *</code> if your compiler supports it).</p>
<p>If you want to work with different types of data, define a function template and use typed pointers, instead of <code>void *</code>. If you want a
single object to be able to stores objects of different types, <code>std::any</code> can also be a type-safe alternative to <code>void*</code>.</p>
<p>If you want to provide to users of an API an opaque type, declare a type and don’t provide its definition (like with <code>FILE*</code>).</p>
<p>Note that <code>void*</code> is commonly used to communicate data of unknown type with C code. This rule will nevertheless raise an issue in this
case, but it can be ignored.</p>
<h3>Noncompliant code example</h3>
<pre>
void saveBuffer(void *buffer, size_t size); // Noncompliant
void duplicate(void* destination, size_t count, void *source, size_t size); // Noncompliant
class Process {
  // ...
  void *userData;
};
using UserData = void*; // Noncompliant
</pre>
<h3>Compliant solution</h3>
<pre>
void saveBuffer(unsigned char *buffer, size_t size);
template&lt;class T&gt;
void duplicate(T* destination, size_t count, T *source);
class Process {
  // ...
  std::any userData;
};
</pre>
<h3>Exceptions</h3>
<p><code>void*</code> can be useful when interfacing with C. As such, the rule will ignore <code>extern ""C""</code> functions, as well as types with
standard layout.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i4-make-interfaces-precisely-and-strongly-typed"">I.4: Make
  interfaces precisely and strongly typed</a> </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t3-use-templates-to-express-containers-and-ranges"">T.3: Use
  templates to express containers and ranges</a> </li>
</ul>",CRITICAL,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKD52TlwiQl6exMGg,cpp:S5008,"Replace this use of ""void *"" with a more meaningful type.","""void *"" should not be used in typedefs, member variables, function parameters or return type","<h2>Why is this an issue?</h2>
<p><code>void*</code> is a pointer to memory of unknown type, and therefore works outside of the safety net provided by the type system. While it can
be useful in a function body to interface with external code, there is no good reason to step out of the robust C++ type system when defining a
function, either for the function parameters, or for the function return type. For the same reasons, having a member variable of type
<code>void*</code> is not recommended.</p>
<p>If you want to work with raw memory buffer, use <code>unsigned char *</code> (or <code>byte *</code> if your compiler supports it).</p>
<p>If you want to work with different types of data, define a function template and use typed pointers, instead of <code>void *</code>. If you want a
single object to be able to stores objects of different types, <code>std::any</code> can also be a type-safe alternative to <code>void*</code>.</p>
<p>If you want to provide to users of an API an opaque type, declare a type and don’t provide its definition (like with <code>FILE*</code>).</p>
<p>Note that <code>void*</code> is commonly used to communicate data of unknown type with C code. This rule will nevertheless raise an issue in this
case, but it can be ignored.</p>
<h3>Noncompliant code example</h3>
<pre>
void saveBuffer(void *buffer, size_t size); // Noncompliant
void duplicate(void* destination, size_t count, void *source, size_t size); // Noncompliant
class Process {
  // ...
  void *userData;
};
using UserData = void*; // Noncompliant
</pre>
<h3>Compliant solution</h3>
<pre>
void saveBuffer(unsigned char *buffer, size_t size);
template&lt;class T&gt;
void duplicate(T* destination, size_t count, T *source);
class Process {
  // ...
  std::any userData;
};
</pre>
<h3>Exceptions</h3>
<p><code>void*</code> can be useful when interfacing with C. As such, the rule will ignore <code>extern ""C""</code> functions, as well as types with
standard layout.</p>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i4-make-interfaces-precisely-and-strongly-typed"">I.4: Make
  interfaces precisely and strongly typed</a> </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t3-use-templates-to-express-containers-and-ranges"">T.3: Use
  templates to express containers and ranges</a> </li>
</ul>",CRITICAL,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKAaATlwiQl6exFUi,c:S1172,"Remove the unused parameter ""r"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAaATlwiQl6exFUj,c:S1172,"Remove the unused parameter ""sqe"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAaATlwiQl6exFUk,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""r"" is ""struct rtio *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKIhiTlwiQl6exRGG,javascript:S2703,"Add the ""let"", ""const"" or ""var"" keyword to this declaration of ""registerDoxygenTooltip"" to make it explicit.",Variables should be declared explicitly,"<h2>Why is this an issue?</h2>
<p>Variable declaration is the process of creating a new variable and specifying its name. JavaScript provides three ways to declare variables: using
the <code>var</code>, <code>let</code>, and <code>const</code> keywords.</p>
<ul>
  <li> The <code>var</code> keyword is used to declare function-scoped or global-scoped variables, i.e. they are accessible throughout the function or
  the entire program, respectively. </li>
  <li> The <code>let</code> keyword is used to declare block-scoped variables, that is, variables accessible only within the nearest curly braces
  block where it is defined. </li>
  <li> The <code>const</code> keyword is used to declare variables that are constant, meaning their values cannot be reassigned. </li>
</ul>
<p>Explicitly declaring variables improves code readability and maintainability. It makes it clear to other developers that you are creating a new
variable and sets expectations about its scope. It also helps catch typos and avoid potential issues caused by accidentally reusing variable
names.</p>
<p>If you assign a value to a variable without declaring it with <code>var</code>, <code>let</code>, or <code>const</code>, JavaScript treats it as an
implicit global variable. Implicit globals can lead to unintended consequences and make it difficult to track and manage variables. They can cause
naming conflicts, make code harder to understand, and introduce bugs that are hard to trace.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
function f() {
  i = 1; // Noncompliant: i is global

  for (j = 0; j &lt; array.length; j++) { // Noncompliant: j is global too
    // ...
  }
}
</pre>
<p>You should explicitly declare all the variables of your code. Use the <code>const</code> keyword if the variable is only assigned once and the
<code>let</code> keyword otherwise.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
function f() {
  const i = 1;

  for (let j = 0; j &lt; array.length; j++) {
    // ...
  }
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> MDN web docs - <a href=""https://developer.mozilla.org/en-US/docs/Glossary/Variable"">Variable</a> </li>
  <li> MDN web docs - <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#declaring_variables"">Declaring
  variables</a> </li>
  <li> MDN web docs - <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#variable_scope"">Variable scope</a>
  </li>
  <li> MDN web docs - <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var"">var</a> </li>
  <li> MDN web docs - <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let"">let</a> </li>
  <li> MDN web docs - <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const"">const</a> </li>
</ul>",BLOCKER,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKIhiTlwiQl6exRGH,javascript:S2004,Refactor this code to not nest functions more than 4 levels deep.,Functions should not be nested too deeply,"<h2>Why is this an issue?</h2>
<p>Nested functions refer to the practice of defining a function within another function. These inner functions have access to the variables and
parameters of the outer function, creating a closure.</p>
<p>While nesting functions is a common practice in JavaScript, deeply nested functions can make the code harder to read and understand, especially if
the functions are long or if there are many levels of nesting.</p>
<p>This can make it difficult for other developers or even yourself to understand and maintain the code.</p>
<h3>Noncompliant code example</h3>
<p>With the default threshold of 4 levels:</p>
<pre>
function f() {
  function f_inner() {
    function f_inner_inner() {
      function f_inner_inner_inner() {
        function f_inner_inner_inner_inner() { // Noncompliant
        }
      }
    }
  }
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> MDN web docs - <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#nested_functions_and_closures"">Nested functions
  and closures</a> </li>
</ul>",CRITICAL,20min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ_TBTlwiQl6exEYI,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ_TBTlwiQl6exEYJ,c:S1854,Value stored to 'rc' is never read,Unused assignments should be removed,"<p>Unused assignments should be removed.</p>
<h2>Why is this an issue?</h2>
<p>Computing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.</p>
<p>Assigning a value to a local variable that is not read by any subsequent instruction is called a <em>dead store</em>. The following code snippet
depicts a few dead stores.</p>
<pre>
int foo() {
  int x = 0; // Noncompliant: dead store, next line overwrites x
  x = 100; // Noncompliant: dead store, next line overwrites x
  x = 200;
  int y = 0;
  y += 9001; // Noncompliant: dead store, y is never used
  int z = 300; // Noncompliant: dead store, next line overwrites z
  z = 400;
  return x + z * 2;
}
</pre>
<p>Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In
most cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code
should be removed to prevent logic errors.</p>
<h2>What is the potential impact?</h2>
<p>Not only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the
absence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.</p>
<p>Unused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover
and eventually prevent logic errors.</p>
<h2>How to fix it</h2>
<p>Remove unused values and superfluous code.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int foo(int y) {
  int x = 0;
  x = 100; // Noncompliant: dead store
  x = 200;
  return x + y;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int foo(int y) {
  int x = 200; // Compliant: no unnecessary assignment
  return x + y;
}
</pre>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  if (x != 0) {
    int y = buz();
    y += 9001; // Noncompliant: dead store
  }
  return x;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // Compliant: no more dead stores and superfluous code
  // Assuming call to buz() had no important side effects
  return x;
}
</pre>
<h3>Pitfalls</h3>
<p>When removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.</p>
<p>While it is safe to remove the call to <code>square</code> in the following code since it has no side effects, removing the call to
<code>fwrite</code> changes the program’s behavior. Still, values that are never read such as <code>n</code> indicate code smells that should be
mitigated. In this code example, the return value of <code>fwrite</code> should be checked and any potential error should be handled
appropriately.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int square(int n) {
  return n * n;
}

int foo(int i) {
  int sq = square(i); // Noncompliant: dead store, assignment can be removed
  const char* const str = ""Hello, World!\n"";
  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects
  size_t n = fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read
  return i + 9001;
}
</pre>
<h3>Going the extra mile</h3>
<p>In C++17, the <code>nodiscard</code> attribute has been introduced which can be used to annotate functions, enumerations and classes.</p>
<p>The attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is
marked <code>nodiscard</code> whose return value is ignored encourages the compiler to issue a warning. Example usages of the <code>nodiscard</code>
attribute are shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }
int bar() { return 200; }
[[nodiscard(""An explanation on why not to discard the return value"")]] int buz() { return 300; }

enum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };
important_error_info compute() {
  // More code ...
  // In case of a critical error, return corresponding error info:
  return important_error_info::CRITICAL;
}

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  bar(); // compiler will issue no warning
  buz(); // compiler warns on discarding a nodiscard value
  compute(); // compiler warns on discarding a nodiscard value
}
</pre>
<p>In case, the return value of a function marked as <code>nodiscard</code> should be (exceptionally) ignored, a cast to <code>void</code> can be used
to silence the compiler warning as shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  (void)foo(); // compiler will issue no warning
}
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> CERT - <a href=""https://wiki.sei.cmu.edu/confluence/x/39UxBQ"">MSC13-C. Detect and remove unused values</a> </li>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/563"">CWE-563 - Assignment to Variable without Use ('Unused Variable')</a> </li>
</ul>
<h3>Related rules</h3>
<ul>
  <li> {rule:c:S1763} - All code should be reachable </li>
  <li> {rule:c:S2583} - Conditionally executed code should be reachable </li>
</ul>",MAJOR,1min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:563']
AZHFJ_TBTlwiQl6exEYK,c:S1854,Value stored to 'rc' is never read,Unused assignments should be removed,"<p>Unused assignments should be removed.</p>
<h2>Why is this an issue?</h2>
<p>Computing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.</p>
<p>Assigning a value to a local variable that is not read by any subsequent instruction is called a <em>dead store</em>. The following code snippet
depicts a few dead stores.</p>
<pre>
int foo() {
  int x = 0; // Noncompliant: dead store, next line overwrites x
  x = 100; // Noncompliant: dead store, next line overwrites x
  x = 200;
  int y = 0;
  y += 9001; // Noncompliant: dead store, y is never used
  int z = 300; // Noncompliant: dead store, next line overwrites z
  z = 400;
  return x + z * 2;
}
</pre>
<p>Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In
most cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code
should be removed to prevent logic errors.</p>
<h2>What is the potential impact?</h2>
<p>Not only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the
absence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.</p>
<p>Unused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover
and eventually prevent logic errors.</p>
<h2>How to fix it</h2>
<p>Remove unused values and superfluous code.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int foo(int y) {
  int x = 0;
  x = 100; // Noncompliant: dead store
  x = 200;
  return x + y;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int foo(int y) {
  int x = 200; // Compliant: no unnecessary assignment
  return x + y;
}
</pre>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  if (x != 0) {
    int y = buz();
    y += 9001; // Noncompliant: dead store
  }
  return x;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // Compliant: no more dead stores and superfluous code
  // Assuming call to buz() had no important side effects
  return x;
}
</pre>
<h3>Pitfalls</h3>
<p>When removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.</p>
<p>While it is safe to remove the call to <code>square</code> in the following code since it has no side effects, removing the call to
<code>fwrite</code> changes the program’s behavior. Still, values that are never read such as <code>n</code> indicate code smells that should be
mitigated. In this code example, the return value of <code>fwrite</code> should be checked and any potential error should be handled
appropriately.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int square(int n) {
  return n * n;
}

int foo(int i) {
  int sq = square(i); // Noncompliant: dead store, assignment can be removed
  const char* const str = ""Hello, World!\n"";
  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects
  size_t n = fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read
  return i + 9001;
}
</pre>
<h3>Going the extra mile</h3>
<p>In C++17, the <code>nodiscard</code> attribute has been introduced which can be used to annotate functions, enumerations and classes.</p>
<p>The attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is
marked <code>nodiscard</code> whose return value is ignored encourages the compiler to issue a warning. Example usages of the <code>nodiscard</code>
attribute are shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }
int bar() { return 200; }
[[nodiscard(""An explanation on why not to discard the return value"")]] int buz() { return 300; }

enum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };
important_error_info compute() {
  // More code ...
  // In case of a critical error, return corresponding error info:
  return important_error_info::CRITICAL;
}

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  bar(); // compiler will issue no warning
  buz(); // compiler warns on discarding a nodiscard value
  compute(); // compiler warns on discarding a nodiscard value
}
</pre>
<p>In case, the return value of a function marked as <code>nodiscard</code> should be (exceptionally) ignored, a cast to <code>void</code> can be used
to silence the compiler warning as shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  (void)foo(); // compiler will issue no warning
}
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> CERT - <a href=""https://wiki.sei.cmu.edu/confluence/x/39UxBQ"">MSC13-C. Detect and remove unused values</a> </li>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/563"">CWE-563 - Assignment to Variable without Use ('Unused Variable')</a> </li>
</ul>
<h3>Related rules</h3>
<ul>
  <li> {rule:c:S1763} - All code should be reachable </li>
  <li> {rule:c:S2583} - Conditionally executed code should be reachable </li>
</ul>",MAJOR,1min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:563']
AZHFJ_TBTlwiQl6exEYM,c:S1854,Value stored to 'rc' is never read,Unused assignments should be removed,"<p>Unused assignments should be removed.</p>
<h2>Why is this an issue?</h2>
<p>Computing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.</p>
<p>Assigning a value to a local variable that is not read by any subsequent instruction is called a <em>dead store</em>. The following code snippet
depicts a few dead stores.</p>
<pre>
int foo() {
  int x = 0; // Noncompliant: dead store, next line overwrites x
  x = 100; // Noncompliant: dead store, next line overwrites x
  x = 200;
  int y = 0;
  y += 9001; // Noncompliant: dead store, y is never used
  int z = 300; // Noncompliant: dead store, next line overwrites z
  z = 400;
  return x + z * 2;
}
</pre>
<p>Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In
most cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code
should be removed to prevent logic errors.</p>
<h2>What is the potential impact?</h2>
<p>Not only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the
absence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.</p>
<p>Unused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover
and eventually prevent logic errors.</p>
<h2>How to fix it</h2>
<p>Remove unused values and superfluous code.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int foo(int y) {
  int x = 0;
  x = 100; // Noncompliant: dead store
  x = 200;
  return x + y;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int foo(int y) {
  int x = 200; // Compliant: no unnecessary assignment
  return x + y;
}
</pre>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  if (x != 0) {
    int y = buz();
    y += 9001; // Noncompliant: dead store
  }
  return x;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // Compliant: no more dead stores and superfluous code
  // Assuming call to buz() had no important side effects
  return x;
}
</pre>
<h3>Pitfalls</h3>
<p>When removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.</p>
<p>While it is safe to remove the call to <code>square</code> in the following code since it has no side effects, removing the call to
<code>fwrite</code> changes the program’s behavior. Still, values that are never read such as <code>n</code> indicate code smells that should be
mitigated. In this code example, the return value of <code>fwrite</code> should be checked and any potential error should be handled
appropriately.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int square(int n) {
  return n * n;
}

int foo(int i) {
  int sq = square(i); // Noncompliant: dead store, assignment can be removed
  const char* const str = ""Hello, World!\n"";
  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects
  size_t n = fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read
  return i + 9001;
}
</pre>
<h3>Going the extra mile</h3>
<p>In C++17, the <code>nodiscard</code> attribute has been introduced which can be used to annotate functions, enumerations and classes.</p>
<p>The attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is
marked <code>nodiscard</code> whose return value is ignored encourages the compiler to issue a warning. Example usages of the <code>nodiscard</code>
attribute are shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }
int bar() { return 200; }
[[nodiscard(""An explanation on why not to discard the return value"")]] int buz() { return 300; }

enum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };
important_error_info compute() {
  // More code ...
  // In case of a critical error, return corresponding error info:
  return important_error_info::CRITICAL;
}

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  bar(); // compiler will issue no warning
  buz(); // compiler warns on discarding a nodiscard value
  compute(); // compiler warns on discarding a nodiscard value
}
</pre>
<p>In case, the return value of a function marked as <code>nodiscard</code> should be (exceptionally) ignored, a cast to <code>void</code> can be used
to silence the compiler warning as shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  (void)foo(); // compiler will issue no warning
}
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> CERT - <a href=""https://wiki.sei.cmu.edu/confluence/x/39UxBQ"">MSC13-C. Detect and remove unused values</a> </li>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/563"">CWE-563 - Assignment to Variable without Use ('Unused Variable')</a> </li>
</ul>
<h3>Related rules</h3>
<ul>
  <li> {rule:c:S1763} - All code should be reachable </li>
  <li> {rule:c:S2583} - Conditionally executed code should be reachable </li>
</ul>",MAJOR,1min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:563']
AZHFKD41TlwiQl6exMEF,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKG0vTlwiQl6exPtm,c:S1172,"Remove the unused parameter ""conn"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKG0vTlwiQl6exPtn,c:S1172,"Remove the unused parameter ""attr"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKG0vTlwiQl6exPtq,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""conn"" is ""struct bt_conn *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKG0vTlwiQl6exPto,c:S1172,"Remove the unused parameter ""offset"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKG0vTlwiQl6exPtp,c:S1172,"Remove the unused parameter ""flags"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKG0vTlwiQl6exPtl,c:S859,cast from 'const void *' to 'unsigned char *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ_NjTlwiQl6exETh,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9fMTlwiQl6exDGH,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9fMTlwiQl6exDGI,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9fMTlwiQl6exDGE,c:S859,cast from 'const struct device *' to 'void *' drops const qualifier,A cast shall not remove any const or volatile qualification from the type of a pointer or reference,"<h2>Why is this an issue?</h2>
<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h3>Noncompliant code example</h3>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/HNcxBQ"">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/P9YxBQ"">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/AHw-BQ"">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>",CRITICAL,20min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ9fMTlwiQl6exDGJ,c:S1172,"Remove the unused parameter ""dma_dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9fMTlwiQl6exDGK,c:S1172,"Remove the unused parameter ""channel"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9fMTlwiQl6exDGL,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""arg"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9fMTlwiQl6exDGF,c:S1481,unused variable 'dev_cfg',Unused local variables should be removed,"<h2>Why is this an issue?</h2>
<p>An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.</p>
<h3>What is the potential impact?</h3>
<p>Having unused local variables in your code can lead to several issues:</p>
<ul>
  <li> <strong>Decreased Readability</strong>: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
  can distract from the main logic of the code. </li>
  <li> <strong>Misunderstanding</strong>: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
  to confusion and misinterpretation of the code’s intent. </li>
  <li> <strong>Potential for Bugs</strong>: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
  declared a variable intending to use it in a calculation, but then forgot to do so, your program might not work as expected. </li>
  <li> <strong>Maintenance Issues</strong>: Unused variables can make code maintenance more difficult. If a programmer sees an unused variable, they
  might think it is a mistake and try to 'fix' the code, potentially introducing new bugs. </li>
  <li> <strong>Memory Usage</strong>: Although modern compilers are smart enough to ignore unused variables, not all compilers do this. In such cases,
  unused variables take up memory space, leading to inefficient use of resources. </li>
</ul>
<p>In summary, unused local variables can make your code less readable, more confusing, and harder to maintain, and they can potentially lead to bugs
or inefficient memory use. Therefore, it is best to remove them.</p>
<h3>Exceptions</h3>
<p>No issue is raised on local variables with the attribute <code>[[maybe_unused]]</code> or <code>unused</code> and object declarations with
non-empty arguments.</p>
<h2>How to fix it</h2>
<p>The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int numberOfMinutes(int hours) {
  int seconds = 0; // Noncompliant second is unused
  return hours * 60;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int numberOfMinutes(int hours) {
  return hours * 60;
}
</pre>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9fMTlwiQl6exDGS,c:S1854,Value stored to 'dev_cfg' during its initialization is never read,Unused assignments should be removed,"<p>Unused assignments should be removed.</p>
<h2>Why is this an issue?</h2>
<p>Computing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.</p>
<p>Assigning a value to a local variable that is not read by any subsequent instruction is called a <em>dead store</em>. The following code snippet
depicts a few dead stores.</p>
<pre>
int foo() {
  int x = 0; // Noncompliant: dead store, next line overwrites x
  x = 100; // Noncompliant: dead store, next line overwrites x
  x = 200;
  int y = 0;
  y += 9001; // Noncompliant: dead store, y is never used
  int z = 300; // Noncompliant: dead store, next line overwrites z
  z = 400;
  return x + z * 2;
}
</pre>
<p>Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In
most cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code
should be removed to prevent logic errors.</p>
<h2>What is the potential impact?</h2>
<p>Not only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the
absence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.</p>
<p>Unused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover
and eventually prevent logic errors.</p>
<h2>How to fix it</h2>
<p>Remove unused values and superfluous code.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int foo(int y) {
  int x = 0;
  x = 100; // Noncompliant: dead store
  x = 200;
  return x + y;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int foo(int y) {
  int x = 200; // Compliant: no unnecessary assignment
  return x + y;
}
</pre>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  if (x != 0) {
    int y = buz();
    y += 9001; // Noncompliant: dead store
  }
  return x;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // Compliant: no more dead stores and superfluous code
  // Assuming call to buz() had no important side effects
  return x;
}
</pre>
<h3>Pitfalls</h3>
<p>When removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.</p>
<p>While it is safe to remove the call to <code>square</code> in the following code since it has no side effects, removing the call to
<code>fwrite</code> changes the program’s behavior. Still, values that are never read such as <code>n</code> indicate code smells that should be
mitigated. In this code example, the return value of <code>fwrite</code> should be checked and any potential error should be handled
appropriately.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int square(int n) {
  return n * n;
}

int foo(int i) {
  int sq = square(i); // Noncompliant: dead store, assignment can be removed
  const char* const str = ""Hello, World!\n"";
  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects
  size_t n = fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read
  return i + 9001;
}
</pre>
<h3>Going the extra mile</h3>
<p>In C++17, the <code>nodiscard</code> attribute has been introduced which can be used to annotate functions, enumerations and classes.</p>
<p>The attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is
marked <code>nodiscard</code> whose return value is ignored encourages the compiler to issue a warning. Example usages of the <code>nodiscard</code>
attribute are shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }
int bar() { return 200; }
[[nodiscard(""An explanation on why not to discard the return value"")]] int buz() { return 300; }

enum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };
important_error_info compute() {
  // More code ...
  // In case of a critical error, return corresponding error info:
  return important_error_info::CRITICAL;
}

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  bar(); // compiler will issue no warning
  buz(); // compiler warns on discarding a nodiscard value
  compute(); // compiler warns on discarding a nodiscard value
}
</pre>
<p>In case, the return value of a function marked as <code>nodiscard</code> should be (exceptionally) ignored, a cast to <code>void</code> can be used
to silence the compiler warning as shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  (void)foo(); // compiler will issue no warning
}
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> CERT - <a href=""https://wiki.sei.cmu.edu/confluence/x/39UxBQ"">MSC13-C. Detect and remove unused values</a> </li>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/563"">CWE-563 - Assignment to Variable without Use ('Unused Variable')</a> </li>
</ul>
<h3>Related rules</h3>
<ul>
  <li> {rule:c:S1763} - All code should be reachable </li>
  <li> {rule:c:S2583} - Conditionally executed code should be reachable </li>
</ul>",MAJOR,1min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:563']
AZHFJ9fMTlwiQl6exDGM,c:S1172,"Remove the unused parameter ""dma_dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9fMTlwiQl6exDGN,c:S1172,"Remove the unused parameter ""channel"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9fMTlwiQl6exDGO,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""arg"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9fMTlwiQl6exDGG,c:S1481,unused variable 'dev_cfg',Unused local variables should be removed,"<h2>Why is this an issue?</h2>
<p>An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,
contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain
clarity and efficiency.</p>
<h3>What is the potential impact?</h3>
<p>Having unused local variables in your code can lead to several issues:</p>
<ul>
  <li> <strong>Decreased Readability</strong>: Unused variables can make your code more difficult to read. They add extra lines and complexity, which
  can distract from the main logic of the code. </li>
  <li> <strong>Misunderstanding</strong>: When other developers read your code, they may wonder why a variable is declared but not used. This can lead
  to confusion and misinterpretation of the code’s intent. </li>
  <li> <strong>Potential for Bugs</strong>: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you
  declared a variable intending to use it in a calculation, but then forgot to do so, your program might not work as expected. </li>
  <li> <strong>Maintenance Issues</strong>: Unused variables can make code maintenance more difficult. If a programmer sees an unused variable, they
  might think it is a mistake and try to 'fix' the code, potentially introducing new bugs. </li>
  <li> <strong>Memory Usage</strong>: Although modern compilers are smart enough to ignore unused variables, not all compilers do this. In such cases,
  unused variables take up memory space, leading to inefficient use of resources. </li>
</ul>
<p>In summary, unused local variables can make your code less readable, more confusing, and harder to maintain, and they can potentially lead to bugs
or inefficient memory use. Therefore, it is best to remove them.</p>
<h3>Exceptions</h3>
<p>No issue is raised on local variables with the attribute <code>[[maybe_unused]]</code> or <code>unused</code> and object declarations with
non-empty arguments.</p>
<h2>How to fix it</h2>
<p>The fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you
just need to remove it.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int numberOfMinutes(int hours) {
  int seconds = 0; // Noncompliant second is unused
  return hours * 60;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int numberOfMinutes(int hours) {
  return hours * 60;
}
</pre>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9fMTlwiQl6exDGT,c:S1854,Value stored to 'dev_cfg' during its initialization is never read,Unused assignments should be removed,"<p>Unused assignments should be removed.</p>
<h2>Why is this an issue?</h2>
<p>Computing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.</p>
<p>Assigning a value to a local variable that is not read by any subsequent instruction is called a <em>dead store</em>. The following code snippet
depicts a few dead stores.</p>
<pre>
int foo() {
  int x = 0; // Noncompliant: dead store, next line overwrites x
  x = 100; // Noncompliant: dead store, next line overwrites x
  x = 200;
  int y = 0;
  y += 9001; // Noncompliant: dead store, y is never used
  int z = 300; // Noncompliant: dead store, next line overwrites z
  z = 400;
  return x + z * 2;
}
</pre>
<p>Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In
most cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code
should be removed to prevent logic errors.</p>
<h2>What is the potential impact?</h2>
<p>Not only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the
absence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.</p>
<p>Unused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover
and eventually prevent logic errors.</p>
<h2>How to fix it</h2>
<p>Remove unused values and superfluous code.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int foo(int y) {
  int x = 0;
  x = 100; // Noncompliant: dead store
  x = 200;
  return x + y;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int foo(int y) {
  int x = 200; // Compliant: no unnecessary assignment
  return x + y;
}
</pre>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  if (x != 0) {
    int y = buz();
    y += 9001; // Noncompliant: dead store
  }
  return x;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // Compliant: no more dead stores and superfluous code
  // Assuming call to buz() had no important side effects
  return x;
}
</pre>
<h3>Pitfalls</h3>
<p>When removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.</p>
<p>While it is safe to remove the call to <code>square</code> in the following code since it has no side effects, removing the call to
<code>fwrite</code> changes the program’s behavior. Still, values that are never read such as <code>n</code> indicate code smells that should be
mitigated. In this code example, the return value of <code>fwrite</code> should be checked and any potential error should be handled
appropriately.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int square(int n) {
  return n * n;
}

int foo(int i) {
  int sq = square(i); // Noncompliant: dead store, assignment can be removed
  const char* const str = ""Hello, World!\n"";
  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects
  size_t n = fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read
  return i + 9001;
}
</pre>
<h3>Going the extra mile</h3>
<p>In C++17, the <code>nodiscard</code> attribute has been introduced which can be used to annotate functions, enumerations and classes.</p>
<p>The attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is
marked <code>nodiscard</code> whose return value is ignored encourages the compiler to issue a warning. Example usages of the <code>nodiscard</code>
attribute are shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }
int bar() { return 200; }
[[nodiscard(""An explanation on why not to discard the return value"")]] int buz() { return 300; }

enum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };
important_error_info compute() {
  // More code ...
  // In case of a critical error, return corresponding error info:
  return important_error_info::CRITICAL;
}

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  bar(); // compiler will issue no warning
  buz(); // compiler warns on discarding a nodiscard value
  compute(); // compiler warns on discarding a nodiscard value
}
</pre>
<p>In case, the return value of a function marked as <code>nodiscard</code> should be (exceptionally) ignored, a cast to <code>void</code> can be used
to silence the compiler warning as shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  (void)foo(); // compiler will issue no warning
}
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> CERT - <a href=""https://wiki.sei.cmu.edu/confluence/x/39UxBQ"">MSC13-C. Detect and remove unused values</a> </li>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/563"">CWE-563 - Assignment to Variable without Use ('Unused Variable')</a> </li>
</ul>
<h3>Related rules</h3>
<ul>
  <li> {rule:c:S1763} - All code should be reachable </li>
  <li> {rule:c:S2583} - Conditionally executed code should be reachable </li>
</ul>",MAJOR,1min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:563']
AZHFJ9fMTlwiQl6exDGP,c:S3776,Refactor this function to reduce its Cognitive Complexity from 67 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ9fMTlwiQl6exDGQ,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""stream"" is ""struct i2s_esp32_stream *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9fMTlwiQl6exDGR,c:S3776,Refactor this function to reduce its Cognitive Complexity from 34 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKHBpTlwiQl6exP8u,c:S954,"Move all #include directives to the very top of the file, before any code.",#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKHBpTlwiQl6exP8x,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKD7DTlwiQl6exMIm,c:S1103,"Remove the misleading ""//"" characters.","""/*"" and ""//"" should not be used within comments","<h2>Why is this an issue?</h2>
<p>Defining a nested single-line comment within a multi-line comment invites errors. It may lead a developer to wrongly think that the lines located
after the single-line comment are not part of the comment.</p>
<p>If a comment starting sequence, <code>/*</code> or <code>//</code>, occurs within a <code>/*</code> comment, is it quite likely to be caused by a
missing <code>*/</code> comment ending sequence.</p>
<p>If a comment starting sequence occurs within a <code>//</code> comment, it is probably because a region of code has been commented-out using
<code>//</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
/* some comment, end comment marker accidentally omitted
// Make sure this function is called in a thread safe context
Perform_Critical_Safety_Function(X);
...
/* this comment is non-compliant */
</pre>
<h3>Exceptions</h3>
<p>The sequence // is permitted within a // comment.</p>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/k9YxBQ"">CERT, MSC04-C.</a> - Use comments consistently and in a readable fashion </li>
  <li> MISRA C:2004, 2.3 - The character sequence /* shall not be used within a comment. </li>
  <li> MISRA C++:2008, 2-7-1 - The character sequence /* shall not be used within a C-style comment. </li>
  <li> MISRA C:2012, 3.1 - The character sequences /* and // shall not be used within a comment </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKD7DTlwiQl6exMIn,c:S1103,"Remove the misleading ""//"" characters.","""/*"" and ""//"" should not be used within comments","<h2>Why is this an issue?</h2>
<p>Defining a nested single-line comment within a multi-line comment invites errors. It may lead a developer to wrongly think that the lines located
after the single-line comment are not part of the comment.</p>
<p>If a comment starting sequence, <code>/*</code> or <code>//</code>, occurs within a <code>/*</code> comment, is it quite likely to be caused by a
missing <code>*/</code> comment ending sequence.</p>
<p>If a comment starting sequence occurs within a <code>//</code> comment, it is probably because a region of code has been commented-out using
<code>//</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
/* some comment, end comment marker accidentally omitted
// Make sure this function is called in a thread safe context
Perform_Critical_Safety_Function(X);
...
/* this comment is non-compliant */
</pre>
<h3>Exceptions</h3>
<p>The sequence // is permitted within a // comment.</p>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/k9YxBQ"">CERT, MSC04-C.</a> - Use comments consistently and in a readable fashion </li>
  <li> MISRA C:2004, 2.3 - The character sequence /* shall not be used within a comment. </li>
  <li> MISRA C++:2008, 2-7-1 - The character sequence /* shall not be used within a C-style comment. </li>
  <li> MISRA C:2012, 3.1 - The character sequences /* and // shall not be used within a comment </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKD7DTlwiQl6exMIo,c:S1103,"Remove the misleading ""//"" characters.","""/*"" and ""//"" should not be used within comments","<h2>Why is this an issue?</h2>
<p>Defining a nested single-line comment within a multi-line comment invites errors. It may lead a developer to wrongly think that the lines located
after the single-line comment are not part of the comment.</p>
<p>If a comment starting sequence, <code>/*</code> or <code>//</code>, occurs within a <code>/*</code> comment, is it quite likely to be caused by a
missing <code>*/</code> comment ending sequence.</p>
<p>If a comment starting sequence occurs within a <code>//</code> comment, it is probably because a region of code has been commented-out using
<code>//</code>.</p>
<h3>Noncompliant code example</h3>
<pre>
/* some comment, end comment marker accidentally omitted
// Make sure this function is called in a thread safe context
Perform_Critical_Safety_Function(X);
...
/* this comment is non-compliant */
</pre>
<h3>Exceptions</h3>
<p>The sequence // is permitted within a // comment.</p>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/k9YxBQ"">CERT, MSC04-C.</a> - Use comments consistently and in a readable fashion </li>
  <li> MISRA C:2004, 2.3 - The character sequence /* shall not be used within a comment. </li>
  <li> MISRA C++:2008, 2-7-1 - The character sequence /* shall not be used within a C-style comment. </li>
  <li> MISRA C:2012, 3.1 - The character sequences /* and // shall not be used within a comment </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9UiTlwiQl6exC_t,c:S954,Move this #include directive to the top of the file.,#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9UiTlwiQl6exC_u,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""cfg"" is ""audio_dai_cfg_t *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9UiTlwiQl6exC_6,c:S1854,Value stored to 'word_size' during its initialization is never read,Unused assignments should be removed,"<p>Unused assignments should be removed.</p>
<h2>Why is this an issue?</h2>
<p>Computing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.</p>
<p>Assigning a value to a local variable that is not read by any subsequent instruction is called a <em>dead store</em>. The following code snippet
depicts a few dead stores.</p>
<pre>
int foo() {
  int x = 0; // Noncompliant: dead store, next line overwrites x
  x = 100; // Noncompliant: dead store, next line overwrites x
  x = 200;
  int y = 0;
  y += 9001; // Noncompliant: dead store, y is never used
  int z = 300; // Noncompliant: dead store, next line overwrites z
  z = 400;
  return x + z * 2;
}
</pre>
<p>Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In
most cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code
should be removed to prevent logic errors.</p>
<h2>What is the potential impact?</h2>
<p>Not only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the
absence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.</p>
<p>Unused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover
and eventually prevent logic errors.</p>
<h2>How to fix it</h2>
<p>Remove unused values and superfluous code.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int foo(int y) {
  int x = 0;
  x = 100; // Noncompliant: dead store
  x = 200;
  return x + y;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int foo(int y) {
  int x = 200; // Compliant: no unnecessary assignment
  return x + y;
}
</pre>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  if (x != 0) {
    int y = buz();
    y += 9001; // Noncompliant: dead store
  }
  return x;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // Compliant: no more dead stores and superfluous code
  // Assuming call to buz() had no important side effects
  return x;
}
</pre>
<h3>Pitfalls</h3>
<p>When removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.</p>
<p>While it is safe to remove the call to <code>square</code> in the following code since it has no side effects, removing the call to
<code>fwrite</code> changes the program’s behavior. Still, values that are never read such as <code>n</code> indicate code smells that should be
mitigated. In this code example, the return value of <code>fwrite</code> should be checked and any potential error should be handled
appropriately.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int square(int n) {
  return n * n;
}

int foo(int i) {
  int sq = square(i); // Noncompliant: dead store, assignment can be removed
  const char* const str = ""Hello, World!\n"";
  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects
  size_t n = fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read
  return i + 9001;
}
</pre>
<h3>Going the extra mile</h3>
<p>In C++17, the <code>nodiscard</code> attribute has been introduced which can be used to annotate functions, enumerations and classes.</p>
<p>The attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is
marked <code>nodiscard</code> whose return value is ignored encourages the compiler to issue a warning. Example usages of the <code>nodiscard</code>
attribute are shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }
int bar() { return 200; }
[[nodiscard(""An explanation on why not to discard the return value"")]] int buz() { return 300; }

enum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };
important_error_info compute() {
  // More code ...
  // In case of a critical error, return corresponding error info:
  return important_error_info::CRITICAL;
}

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  bar(); // compiler will issue no warning
  buz(); // compiler warns on discarding a nodiscard value
  compute(); // compiler warns on discarding a nodiscard value
}
</pre>
<p>In case, the return value of a function marked as <code>nodiscard</code> should be (exceptionally) ignored, a cast to <code>void</code> can be used
to silence the compiler warning as shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  (void)foo(); // compiler will issue no warning
}
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> CERT - <a href=""https://wiki.sei.cmu.edu/confluence/x/39UxBQ"">MSC13-C. Detect and remove unused values</a> </li>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/563"">CWE-563 - Assignment to Variable without Use ('Unused Variable')</a> </li>
</ul>
<h3>Related rules</h3>
<ul>
  <li> {rule:c:S1763} - All code should be reachable </li>
  <li> {rule:c:S2583} - Conditionally executed code should be reachable </li>
</ul>",MAJOR,1min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:563']
AZHFJ9UiTlwiQl6exC_v,c:S1110,Remove these redundant parentheses.,Redundant pairs of parentheses should be removed,"<h2>Why is this an issue?</h2>
<p>Parentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.</p>
<pre>
a = (b * c) + (d * e); // Compliant: the intent is clear.
</pre>
<p>Redundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify
the code. They should be removed.</p>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int x = ((y / 2 + 1)); // Noncompliant

if (a &amp;&amp; ((x + y &gt; 0))) { // Noncompliant
  return ((x + 1)); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int x = (y / 2 + 1);

if (a &amp;&amp; (x + y &gt; 0)) {
  return (x + 1);
}
</pre>
<h3>Exceptions</h3>
<p>Assignments inside conditions are often the result of a mistake. {rule:c:S1121} flags this potential bug.</p>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
if (x = 7) { // Noncompliant: Did the author mean ""x == 7""?
  // ...
}
</pre>
<p>Adding a pair of parentheses to clearly state the intent is standard practice and is accepted by this rule.</p>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
if ((x = 7)) { // Compliant
  // ...
}
</pre>",MAJOR,1min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9UiTlwiQl6exC_w,c:S1110,Remove these redundant parentheses.,Redundant pairs of parentheses should be removed,"<h2>Why is this an issue?</h2>
<p>Parentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.</p>
<pre>
a = (b * c) + (d * e); // Compliant: the intent is clear.
</pre>
<p>Redundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify
the code. They should be removed.</p>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int x = ((y / 2 + 1)); // Noncompliant

if (a &amp;&amp; ((x + y &gt; 0))) { // Noncompliant
  return ((x + 1)); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int x = (y / 2 + 1);

if (a &amp;&amp; (x + y &gt; 0)) {
  return (x + 1);
}
</pre>
<h3>Exceptions</h3>
<p>Assignments inside conditions are often the result of a mistake. {rule:c:S1121} flags this potential bug.</p>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
if (x = 7) { // Noncompliant: Did the author mean ""x == 7""?
  // ...
}
</pre>
<p>Adding a pair of parentheses to clearly state the intent is standard practice and is accepted by this rule.</p>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
if ((x = 7)) { // Compliant
  // ...
}
</pre>",MAJOR,1min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9UiTlwiQl6exC_x,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9UiTlwiQl6exC_y,c:S2234,Parameters have the same names but not the same order as the method arguments.,Parameters should be passed in the correct order,"<h2>Why is this an issue?</h2>
<p>When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when
the names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead
to unexpected results.</p>
<h3>Noncompliant code example</h3>
<pre>
int divide(int divisor, int dividend) {
  return divisor / dividend;
}

void doTheThing() {
  int divisor = 15;
  int dividend = 5;

  int result = divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected
  //...
}
</pre>
<h3>Compliant solution</h3>
<pre>
int divide(int divisor, int dividend) {
  return divisor / dividend;
}

void doTheThing() {
  int divisor = 15;
  int dividend = 5;

  int result = divide(divisor, dividend);
  //...
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9UiTlwiQl6exC_z,c:S2234,Parameters have the same names but not the same order as the method arguments.,Parameters should be passed in the correct order,"<h2>Why is this an issue?</h2>
<p>When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when
the names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead
to unexpected results.</p>
<h3>Noncompliant code example</h3>
<pre>
int divide(int divisor, int dividend) {
  return divisor / dividend;
}

void doTheThing() {
  int divisor = 15;
  int dividend = 5;

  int result = divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected
  //...
}
</pre>
<h3>Compliant solution</h3>
<pre>
int divide(int divisor, int dividend) {
  return divisor / dividend;
}

void doTheThing() {
  int divisor = 15;
  int dividend = 5;

  int result = divide(divisor, dividend);
  //...
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9UiTlwiQl6exC_0,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""cfg"" is ""audio_dai_cfg_t *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9UiTlwiQl6exC_1,c:S1110,Remove these redundant parentheses.,Redundant pairs of parentheses should be removed,"<h2>Why is this an issue?</h2>
<p>Parentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.</p>
<pre>
a = (b * c) + (d * e); // Compliant: the intent is clear.
</pre>
<p>Redundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify
the code. They should be removed.</p>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int x = ((y / 2 + 1)); // Noncompliant

if (a &amp;&amp; ((x + y &gt; 0))) { // Noncompliant
  return ((x + 1)); // Noncompliant
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int x = (y / 2 + 1);

if (a &amp;&amp; (x + y &gt; 0)) {
  return (x + 1);
}
</pre>
<h3>Exceptions</h3>
<p>Assignments inside conditions are often the result of a mistake. {rule:c:S1121} flags this potential bug.</p>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
if (x = 7) { // Noncompliant: Did the author mean ""x == 7""?
  // ...
}
</pre>
<p>Adding a pair of parentheses to clearly state the intent is standard practice and is accepted by this rule.</p>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
if ((x = 7)) { // Compliant
  // ...
}
</pre>",MAJOR,1min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9UiTlwiQl6exC_9,c:S125,Remove the commented out code.,Sections of code should not be commented out,"<h2>Why is this an issue?</h2>
<p>Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never
executed, it quickly becomes out of date and invalid.</p>
<p>Commented-out code should be deleted and can be retrieved from source control history if required.</p>
<h3>Exceptions</h3>
<p>This rule does not apply to code documentation using Doxygen, QDoc, markdown, or HTML tags.</p>
<h2>Resources</h2>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 2.4 - Sections of code should not be ""commented out"". </li>
  <li> MISRA C++:2008, 2-7-2 - Sections of code shall not be ""commented out"" using C-style comments. </li>
  <li> MISRA C++:2008, 2-7-3 - Sections of code should not be ""commented out"" using C++ comments. </li>
  <li> MISRA C:2012, Dir. 4.4 - Sections of code should not be ""commented out"" </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9UiTlwiQl6exC_3,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9UiTlwiQl6exC_2,c:S1186,"Add a nested comment explaining why this method is empty, or complete the implementation.",Methods should not be empty,"<h2>Why is this an issue?</h2>
<p>An empty function is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty functions bring no
functionality and are misleading to others as they might think the function implementation fulfills a specific and identified requirement.</p>
<p>There are several reasons for a function not to have a body:</p>
<ul>
  <li> It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. </li>
  <li> It is not yet, or never will be, supported. In this case an exception should be thrown. </li>
  <li> The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. </li>
</ul>
<h3>Exceptions</h3>
<p>This rule doesn’t raise an issue for empty class constructors or destructors.</p>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void shouldNotBeEmpty() {  // Noncompliant - method is empty
}

void notImplemented() {  // Noncompliant - method is empty
}

void emptyOnPurpose() {  // Noncompliant - method is empty
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void shouldNotBeEmpty() {
  doSomething();
}

void notImplemented() {
  throw std::logic_exception(""notImplemented() cannot be performed because..."");
}

void emptyOnPurpose() {
  // comment explaining why the method is empty
}
</pre>",CRITICAL,5min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ9UiTlwiQl6exC_5,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9UiTlwiQl6exC_4,c:S1186,"Add a nested comment explaining why this method is empty, or complete the implementation.",Methods should not be empty,"<h2>Why is this an issue?</h2>
<p>An empty function is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty functions bring no
functionality and are misleading to others as they might think the function implementation fulfills a specific and identified requirement.</p>
<p>There are several reasons for a function not to have a body:</p>
<ul>
  <li> It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. </li>
  <li> It is not yet, or never will be, supported. In this case an exception should be thrown. </li>
  <li> The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. </li>
</ul>
<h3>Exceptions</h3>
<p>This rule doesn’t raise an issue for empty class constructors or destructors.</p>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void shouldNotBeEmpty() {  // Noncompliant - method is empty
}

void notImplemented() {  // Noncompliant - method is empty
}

void emptyOnPurpose() {  // Noncompliant - method is empty
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void shouldNotBeEmpty() {
  doSomething();
}

void notImplemented() {
  throw std::logic_exception(""notImplemented() cannot be performed because..."");
}

void emptyOnPurpose() {
  // comment explaining why the method is empty
}
</pre>",CRITICAL,5min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKE0pTlwiQl6exM39,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""config"" is ""struct i2s_config *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKE0pTlwiQl6exM3-,c:S3776,Refactor this function to reduce its Cognitive Complexity from 31 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKE0pTlwiQl6exM4C,c:S924,"Reduce the number of nested ""break"" statements from 2 to 1 authorized.","Loops should not have more than one ""break"" or ""goto"" statement","<h2>Why is this an issue?</h2>
<p>Restricting the number of exits from a loop is done in the interests of good structured programming. One <code>break</code> or <code>goto</code>
statement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.</p>
<h3>Noncompliant code example</h3>
<p>With the default threshold of 1:</p>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
  else if (...) {
    break;      //  Non-compliant - second jump from loop
  }
  else {
    ...
  }
}
while (...) {
  if (...) {
    break;      // Compliant
  }
  if (...) {
    break;      // Non-compliant - second jump from loop
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
}
while (...) {
  if (...) {
    break;    // Compliant
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. </li>
  <li> MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. </li>
  <li> MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement </li>
</ul>",MAJOR,20min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKE0pTlwiQl6exM3_,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKE0pTlwiQl6exM4A,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ9qLTlwiQl6exDM0,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""p3"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9qLTlwiQl6exDMw,c:S1172,"Remove the unused parameter ""p2"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9qLTlwiQl6exDMx,c:S1172,"Remove the unused parameter ""p3"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9qLTlwiQl6exDMy,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""p1"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9qLTlwiQl6exDMz,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""p2"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKG0hTlwiQl6exPtf,c:S954,Move these 2 #include directives to the top of the file.,#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKG0hTlwiQl6exPtg,c:S1172,"Remove the unused parameter ""attr"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKG0hTlwiQl6exPth,c:S1172,"Remove the unused parameter ""conn"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKG0hTlwiQl6exPti,c:S1172,"Remove the unused parameter ""attr"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKG0hTlwiQl6exPtk,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""conn"" is ""struct bt_conn *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKG0hTlwiQl6exPtj,c:S1172,"Remove the unused parameter ""flags"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ_3-TlwiQl6exE6z,c:S1066,"Merge this ""if"" statement with the enclosing one.","Mergeable ""if"" statements should be combined","<h2>Why is this an issue?</h2>
<p>Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as
possible, by avoiding unnecessary nesting, is considered a good practice.</p>
<p>Merging <code>if</code> statements when possible will decrease the nesting of the code and improve its readability.</p>
<p>Code like</p>
<pre>
if (condition1) {
  if (condition2) {             // Noncompliant
    /* ... */
  }
}
</pre>
<p>will be more readable as</p>
<pre>
if (condition1 &amp;&amp; condition2) { // Compliant
  /* ... */
}
</pre>
<h2>How to fix it</h2>
<p>If merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a
better approach to fix readability.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
if (fs::exists(path)) {
  if (fs::is_regular_file(path) || fs::is_directory(path)) { // Noncompliant
    /* ... */
  }
}
</pre>
<h4>Compliant solution</h4>
<pre>
bool isFileOrDirectory(fs::path const&amp; path) {
  return fs::is_regular_file(path) || fs::is_directory(path);
}

/* ... */

if (fs::exists(path) &amp;&amp; isFileOrDirectory(path)) { // Compliant
  /* ... */
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ_RrTlwiQl6exEXk,c:S924,"Reduce the number of nested ""goto"" statements from 3 to 1 authorized.","Loops should not have more than one ""break"" or ""goto"" statement","<h2>Why is this an issue?</h2>
<p>Restricting the number of exits from a loop is done in the interests of good structured programming. One <code>break</code> or <code>goto</code>
statement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.</p>
<h3>Noncompliant code example</h3>
<p>With the default threshold of 1:</p>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
  else if (...) {
    break;      //  Non-compliant - second jump from loop
  }
  else {
    ...
  }
}
while (...) {
  if (...) {
    break;      // Compliant
  }
  if (...) {
    break;      // Non-compliant - second jump from loop
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
}
while (...) {
  if (...) {
    break;    // Compliant
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. </li>
  <li> MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. </li>
  <li> MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement </li>
</ul>",MAJOR,20min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ_RrTlwiQl6exEXl,c:S924,"Reduce the number of nested ""goto"" statements from 2 to 1 authorized.","Loops should not have more than one ""break"" or ""goto"" statement","<h2>Why is this an issue?</h2>
<p>Restricting the number of exits from a loop is done in the interests of good structured programming. One <code>break</code> or <code>goto</code>
statement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.</p>
<h3>Noncompliant code example</h3>
<p>With the default threshold of 1:</p>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
  else if (...) {
    break;      //  Non-compliant - second jump from loop
  }
  else {
    ...
  }
}
while (...) {
  if (...) {
    break;      // Compliant
  }
  if (...) {
    break;      // Non-compliant - second jump from loop
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
}
while (...) {
  if (...) {
    break;    // Compliant
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. </li>
  <li> MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. </li>
  <li> MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement </li>
</ul>",MAJOR,20min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ_RrTlwiQl6exEXn,c:S924,"Reduce the number of nested ""goto"" statements from 2 to 1 authorized.","Loops should not have more than one ""break"" or ""goto"" statement","<h2>Why is this an issue?</h2>
<p>Restricting the number of exits from a loop is done in the interests of good structured programming. One <code>break</code> or <code>goto</code>
statement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.</p>
<h3>Noncompliant code example</h3>
<p>With the default threshold of 1:</p>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
  else if (...) {
    break;      //  Non-compliant - second jump from loop
  }
  else {
    ...
  }
}
while (...) {
  if (...) {
    break;      // Compliant
  }
  if (...) {
    break;      // Non-compliant - second jump from loop
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
}
while (...) {
  if (...) {
    break;    // Compliant
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. </li>
  <li> MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. </li>
  <li> MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement </li>
</ul>",MAJOR,20min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8DeTlwiQl6exCUT,c:S1172,"Remove the unused parameter ""chan"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8DRTlwiQl6exCUN,c:S1172,"Remove the unused parameter ""chan"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8DRTlwiQl6exCUO,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""data"" is ""struct jc42_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8DRTlwiQl6exCUP,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ8DRTlwiQl6exCUQ,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""data"" is ""struct jc42_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8DRTlwiQl6exCUR,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""p2"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ8DRTlwiQl6exCUS,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""p3"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKIotTlwiQl6exRLF,c:S3776,Refactor this function to reduce its Cognitive Complexity from 71 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKIotTlwiQl6exRLM,c:S3776,Refactor this function to reduce its Cognitive Complexity from 110 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKIpITlwiQl6exRLp,c:S954,"Move all #include directives to the very top of the file, before any code.",#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKIpITlwiQl6exRLq,c:S1172,"Remove the unused parameter ""ctx"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKIpITlwiQl6exRLr,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""ctx"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKIpITlwiQl6exRLs,c:S1172,"Remove the unused parameter ""timeout_ctx"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKIpITlwiQl6exRLt,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""timeout_ctx"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKIpITlwiQl6exRL0,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKIpITlwiQl6exRL2,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKFMUTlwiQl6exNP0,c:S3776,Refactor this function to reduce its Cognitive Complexity from 73 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKErtTlwiQl6exMzC,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKABVTlwiQl6exE9T,c:S1066,"Merge this ""if"" statement with the enclosing one.","Mergeable ""if"" statements should be combined","<h2>Why is this an issue?</h2>
<p>Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as
possible, by avoiding unnecessary nesting, is considered a good practice.</p>
<p>Merging <code>if</code> statements when possible will decrease the nesting of the code and improve its readability.</p>
<p>Code like</p>
<pre>
if (condition1) {
  if (condition2) {             // Noncompliant
    /* ... */
  }
}
</pre>
<p>will be more readable as</p>
<pre>
if (condition1 &amp;&amp; condition2) { // Compliant
  /* ... */
}
</pre>
<h2>How to fix it</h2>
<p>If merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a
better approach to fix readability.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
if (fs::exists(path)) {
  if (fs::is_regular_file(path) || fs::is_directory(path)) { // Noncompliant
    /* ... */
  }
}
</pre>
<h4>Compliant solution</h4>
<pre>
bool isFileOrDirectory(fs::path const&amp; path) {
  return fs::is_regular_file(path) || fs::is_directory(path);
}

/* ... */

if (fs::exists(path) &amp;&amp; isFileOrDirectory(path)) { // Compliant
  /* ... */
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKGmwTlwiQl6exPab,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""groups"" is ""unsigned short *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9OrTlwiQl6exC8a,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9TgTlwiQl6exC-l,c:S1116,"Modify the macro definition so that it needs to be followed by a semicolon, or remove this empty statement.",Empty statements should be removed,"<h2>Why is this an issue?</h2>
<p>Empty statements represented by a semicolon <code>;</code> are statements that do not perform any operation. They are often the result of a typo or
a misunderstanding of the language syntax. It is a good practice to remove empty statements since they don’t add value and lead to confusion and
errors.</p>
<h3>Exceptions</h3>
<p>In the case of an empty expanded macro, the issue is not raised.</p>
<pre>
#define LOG(x)

void fun() {
  LOG(X);
}
</pre>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething() {
  ;                // Noncompliant - was used as a kind of TODO marker
}

#define A(x) x;    // Noncompliant - macro definitions should not end with a semi-colon when they are used as functions

void fun() {
  A(5);            // Noncompliant - after expansion, there are 2 consecutive semi-colons
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething() {
}

#define A(x) x

void fun() {
  A(5);
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that
  the first character following the null statement is a white-space character. </li>
  <li> MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided
  that the first character following the null statement is a white-space character. </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/WtYxBQ"">CERT, EXP15-C.</a> - Do not place a semicolon on the same line as an if, for, or while
  statement </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-8WTlwiQl6exEGb,c:S3776,Refactor this function to reduce its Cognitive Complexity from 28 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKGgeTlwiQl6exPQ2,c:S1066,"Merge this ""if"" statement with the enclosing one.","Mergeable ""if"" statements should be combined","<h2>Why is this an issue?</h2>
<p>Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as
possible, by avoiding unnecessary nesting, is considered a good practice.</p>
<p>Merging <code>if</code> statements when possible will decrease the nesting of the code and improve its readability.</p>
<p>Code like</p>
<pre>
if (condition1) {
  if (condition2) {             // Noncompliant
    /* ... */
  }
}
</pre>
<p>will be more readable as</p>
<pre>
if (condition1 &amp;&amp; condition2) { // Compliant
  /* ... */
}
</pre>
<h2>How to fix it</h2>
<p>If merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a
better approach to fix readability.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
if (fs::exists(path)) {
  if (fs::is_regular_file(path) || fs::is_directory(path)) { // Noncompliant
    /* ... */
  }
}
</pre>
<h4>Compliant solution</h4>
<pre>
bool isFileOrDirectory(fs::path const&amp; path) {
  return fs::is_regular_file(path) || fs::is_directory(path);
}

/* ... */

if (fs::exists(path) &amp;&amp; isFileOrDirectory(path)) { // Compliant
  /* ... */
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAAGTlwiQl6exE88,c:S954,Move these 2 #include directives to the top of the file.,#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKAAATlwiQl6exE87,c:S954,Move these 2 #include directives to the top of the file.,#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ__5TlwiQl6exE86,c:S954,Move these 2 #include directives to the top of the file.,#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ__GTlwiQl6exE8z,c:S954,Move these 2 #include directives to the top of the file.,#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ7XqTlwiQl6exCAP,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ7QJTlwiQl6exB6s,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ7SrTlwiQl6exB8X,c:S1905,Remove this redundant cast.,Redundant casts should not be used,"<h2>Why is this an issue?</h2>
<p>Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in
strongly typed languages like C, C++, C#, Java, Python, and others.</p>
<p>However, there are instances where casting expressions are not needed. These include situations like:</p>
<ul>
  <li> casting a variable to its own type </li>
  <li> casting a subclass to a parent class (in the case of polymorphism) </li>
  <li> the programming language is capable of automatically converting the given type to another </li>
</ul>
<p>These scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without
offering any advantages.</p>
<p>As a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and
code clarity.</p>
<h3>Exceptions</h3>
<p>In some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on
one platform but not on the others.</p>
<h2>How to fix it</h2>
<p>To fix your code, remove the unnecessary casting expression.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int example(int i) {
  int result = static_cast&lt;int&gt;(i + 42); // Noncompliant
  return (int) result; // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int example(int i) {
 int result = i + 42;
 return result;
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Type_conversion"">Type Conversion</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Strong_and_weak_typing"">Strong and Weak Typing</a> </li>
  <li> Wikipedia - <a href=""https://en.wikipedia.org/wiki/Polymorphism_(computer_science)""> Polymorphism (Computer Science)</a> </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-HsTlwiQl6exDee,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""cfg"" is ""struct udc_ep_config *const"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-HsTlwiQl6exDef,c:S3776,Refactor this function to reduce its Cognitive Complexity from 39 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ-HsTlwiQl6exDe8,c:S1854,Value stored to 'pktcnt' is never read,Unused assignments should be removed,"<p>Unused assignments should be removed.</p>
<h2>Why is this an issue?</h2>
<p>Computing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.</p>
<p>Assigning a value to a local variable that is not read by any subsequent instruction is called a <em>dead store</em>. The following code snippet
depicts a few dead stores.</p>
<pre>
int foo() {
  int x = 0; // Noncompliant: dead store, next line overwrites x
  x = 100; // Noncompliant: dead store, next line overwrites x
  x = 200;
  int y = 0;
  y += 9001; // Noncompliant: dead store, y is never used
  int z = 300; // Noncompliant: dead store, next line overwrites z
  z = 400;
  return x + z * 2;
}
</pre>
<p>Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In
most cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code
should be removed to prevent logic errors.</p>
<h2>What is the potential impact?</h2>
<p>Not only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the
absence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.</p>
<p>Unused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover
and eventually prevent logic errors.</p>
<h2>How to fix it</h2>
<p>Remove unused values and superfluous code.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int foo(int y) {
  int x = 0;
  x = 100; // Noncompliant: dead store
  x = 200;
  return x + y;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int foo(int y) {
  int x = 200; // Compliant: no unnecessary assignment
  return x + y;
}
</pre>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  if (x != 0) {
    int y = buz();
    y += 9001; // Noncompliant: dead store
  }
  return x;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // Compliant: no more dead stores and superfluous code
  // Assuming call to buz() had no important side effects
  return x;
}
</pre>
<h3>Pitfalls</h3>
<p>When removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.</p>
<p>While it is safe to remove the call to <code>square</code> in the following code since it has no side effects, removing the call to
<code>fwrite</code> changes the program’s behavior. Still, values that are never read such as <code>n</code> indicate code smells that should be
mitigated. In this code example, the return value of <code>fwrite</code> should be checked and any potential error should be handled
appropriately.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int square(int n) {
  return n * n;
}

int foo(int i) {
  int sq = square(i); // Noncompliant: dead store, assignment can be removed
  const char* const str = ""Hello, World!\n"";
  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects
  size_t n = fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read
  return i + 9001;
}
</pre>
<h3>Going the extra mile</h3>
<p>In C++17, the <code>nodiscard</code> attribute has been introduced which can be used to annotate functions, enumerations and classes.</p>
<p>The attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is
marked <code>nodiscard</code> whose return value is ignored encourages the compiler to issue a warning. Example usages of the <code>nodiscard</code>
attribute are shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }
int bar() { return 200; }
[[nodiscard(""An explanation on why not to discard the return value"")]] int buz() { return 300; }

enum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };
important_error_info compute() {
  // More code ...
  // In case of a critical error, return corresponding error info:
  return important_error_info::CRITICAL;
}

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  bar(); // compiler will issue no warning
  buz(); // compiler warns on discarding a nodiscard value
  compute(); // compiler warns on discarding a nodiscard value
}
</pre>
<p>In case, the return value of a function marked as <code>nodiscard</code> should be (exceptionally) ignored, a cast to <code>void</code> can be used
to silence the compiler warning as shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  (void)foo(); // compiler will issue no warning
}
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> CERT - <a href=""https://wiki.sei.cmu.edu/confluence/x/39UxBQ"">MSC13-C. Detect and remove unused values</a> </li>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/563"">CWE-563 - Assignment to Variable without Use ('Unused Variable')</a> </li>
</ul>
<h3>Related rules</h3>
<ul>
  <li> {rule:c:S1763} - All code should be reachable </li>
  <li> {rule:c:S2583} - Conditionally executed code should be reachable </li>
</ul>",MAJOR,1min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:563']
AZHFJ-HsTlwiQl6exDe9,c:S1854,Value stored to 'pktcnt' is never read,Unused assignments should be removed,"<p>Unused assignments should be removed.</p>
<h2>Why is this an issue?</h2>
<p>Computing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.</p>
<p>Assigning a value to a local variable that is not read by any subsequent instruction is called a <em>dead store</em>. The following code snippet
depicts a few dead stores.</p>
<pre>
int foo() {
  int x = 0; // Noncompliant: dead store, next line overwrites x
  x = 100; // Noncompliant: dead store, next line overwrites x
  x = 200;
  int y = 0;
  y += 9001; // Noncompliant: dead store, y is never used
  int z = 300; // Noncompliant: dead store, next line overwrites z
  z = 400;
  return x + z * 2;
}
</pre>
<p>Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In
most cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code
should be removed to prevent logic errors.</p>
<h2>What is the potential impact?</h2>
<p>Not only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the
absence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.</p>
<p>Unused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover
and eventually prevent logic errors.</p>
<h2>How to fix it</h2>
<p>Remove unused values and superfluous code.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
int foo(int y) {
  int x = 0;
  x = 100; // Noncompliant: dead store
  x = 200;
  return x + y;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
int foo(int y) {
  int x = 200; // Compliant: no unnecessary assignment
  return x + y;
}
</pre>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""2"" data-diff-type=""noncompliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  if (x != 0) {
    int y = buz();
    y += 9001; // Noncompliant: dead store
  }
  return x;
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""2"" data-diff-type=""compliant"">
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // Compliant: no more dead stores and superfluous code
  // Assuming call to buz() had no important side effects
  return x;
}
</pre>
<h3>Pitfalls</h3>
<p>When removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.</p>
<p>While it is safe to remove the call to <code>square</code> in the following code since it has no side effects, removing the call to
<code>fwrite</code> changes the program’s behavior. Still, values that are never read such as <code>n</code> indicate code smells that should be
mitigated. In this code example, the return value of <code>fwrite</code> should be checked and any potential error should be handled
appropriately.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int square(int n) {
  return n * n;
}

int foo(int i) {
  int sq = square(i); // Noncompliant: dead store, assignment can be removed
  const char* const str = ""Hello, World!\n"";
  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects
  size_t n = fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read
  return i + 9001;
}
</pre>
<h3>Going the extra mile</h3>
<p>In C++17, the <code>nodiscard</code> attribute has been introduced which can be used to annotate functions, enumerations and classes.</p>
<p>The attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is
marked <code>nodiscard</code> whose return value is ignored encourages the compiler to issue a warning. Example usages of the <code>nodiscard</code>
attribute are shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }
int bar() { return 200; }
[[nodiscard(""An explanation on why not to discard the return value"")]] int buz() { return 300; }

enum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };
important_error_info compute() {
  // More code ...
  // In case of a critical error, return corresponding error info:
  return important_error_info::CRITICAL;
}

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  bar(); // compiler will issue no warning
  buz(); // compiler warns on discarding a nodiscard value
  compute(); // compiler warns on discarding a nodiscard value
}
</pre>
<p>In case, the return value of a function marked as <code>nodiscard</code> should be (exceptionally) ignored, a cast to <code>void</code> can be used
to silence the compiler warning as shown in the following:</p>
<pre>
[[nodiscard]] int foo() { return 100; }

void caller() {
  foo(); // compiler warns on discarding a nodiscard value
  (void)foo(); // compiler will issue no warning
}
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> CERT - <a href=""https://wiki.sei.cmu.edu/confluence/x/39UxBQ"">MSC13-C. Detect and remove unused values</a> </li>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/563"">CWE-563 - Assignment to Variable without Use ('Unused Variable')</a> </li>
</ul>
<h3>Related rules</h3>
<ul>
  <li> {rule:c:S1763} - All code should be reachable </li>
  <li> {rule:c:S2583} - Conditionally executed code should be reachable </li>
</ul>",MAJOR,1min,LOGICAL,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:563']
AZHFJ-HsTlwiQl6exDeq,c:S3458,"Remove this redundant ""case"" clause.","Empty ""case"" clauses that fall through to the ""default"" should be omitted","<h2>Why is this an issue?</h2>
<p>Empty <code>case</code> clauses that fall through to the default are useless. Whether or not such a <code>case</code> is present, the
<code>default</code> clause will be invoked. Such <code>case</code>s simply clutter the code, and should be removed.</p>
<h3>Noncompliant code example</h3>
<pre>
switch(ch)
{
  case 'a' :
    handleA();
    break;
  case 'b' :
    handleB();
    break;
  case 'c' :  // Noncompliant
  default:
    handleTheRest();
    break;
}
</pre>
<h3>Compliant solution</h3>
<pre>
switch(ch)
{
  case 'a' :
    handleA();
    break;
  case 'b' :
    handleB();
    break;
  default:
    handleTheRest();
    break;
}
</pre>",MINOR,1min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-HsTlwiQl6exDes,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""priv"" is ""struct udc_dwc2_data *const"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-HsTlwiQl6exDer,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ-HsTlwiQl6exDeu,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""priv"" is ""struct udc_dwc2_data *const"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-HsTlwiQl6exDet,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFNITlwiQl6exNR2,c:S1172,"Remove the unused parameter ""mgmt_request"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKDXITlwiQl6exIpK,c:S954,Move this #include directive to the top of the file.,#include directives in a file should only be preceded by other preprocessor directives or comments,"<h2>Why is this an issue?</h2>
<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.
The only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>
<p>Additionally, an <code>#include</code> may appear within an <code>extern ""C""</code> block, this can be used for instance to include a C file from a
C++ file.</p>
<h3>Noncompliant code example</h3>
<pre>
#include &lt;h1.h&gt; /* Compliant */
int32_t i;
#include &lt;f2.h&gt; /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#include &lt;h1.h&gt;
#include &lt;f2.h&gt;
extern ""C"" {
#include &lt;f3.h&gt;
}

int32_t i;
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>
  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>
</ul>",MAJOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKBgBTlwiQl6exGVW,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""f"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBgBTlwiQl6exGVX,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""fixture"" is ""struct cap_initiator_test_unicast_start_fixture *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBgZTlwiQl6exGVq,c:S1172,"Remove the unused parameter ""stream"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKBgZTlwiQl6exGVr,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""stream"" is ""struct bt_bap_stream *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9kaTlwiQl6exDJe,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9kaTlwiQl6exDJi,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9kaTlwiQl6exDJj,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9kaTlwiQl6exDJk,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9kaTlwiQl6exDJl,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9kaTlwiQl6exDJn,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9kaTlwiQl6exDJp,c:S3776,Refactor this function to reduce its Cognitive Complexity from 32 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKHx2TlwiQl6exQjV,c:S3776,Refactor this function to reduce its Cognitive Complexity from 28 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKHx2TlwiQl6exQjW,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKHx2TlwiQl6exQjQ,c:S1135,"Complete the task associated to this ""TODO"" comment.","Track uses of ""TODO"" tags","<h2>Why is this an issue?</h2>
<p>Developers often use <code>TODO</code> tags to mark areas in the code where additional work or improvements are needed but are not implemented
immediately. However, these <code>TODO</code> tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to
identify and address unattended <code>TODO</code> tags to ensure a clean and maintainable codebase. This description explores why this is a problem
and how it can be fixed to improve the overall code quality.</p>
<h3>What is the potential impact?</h3>
<p>Unattended <code>TODO</code> tags in code can have significant implications for the development process and the overall codebase.</p>
<p>Incomplete Functionality: When developers leave <code>TODO</code> tags without implementing the corresponding code, it results in incomplete
functionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.</p>
<p>Missed Bug Fixes: If developers do not promptly address <code>TODO</code> tags, they might overlook critical bug fixes and security updates.
Delayed bug fixes can result in more severe issues and increase the effort required to resolve them later.</p>
<p>Impact on Collaboration: In team-based development environments, unattended <code>TODO</code> tags can hinder collaboration. Other team members
might not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.</p>
<p>Codebase Bloat: The accumulation of unattended <code>TODO</code> tags over time can clutter the codebase and make it difficult to distinguish
between work in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.</p>
<p>Addressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among
developers.</p>
<h3>Noncompliant code example</h3>
<pre>
void foo() {
  // TODO
}
</pre>
<h2>Resources</h2>
<ul>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/546"">CWE-546 - Suspicious Comment</a> </li>
</ul>",INFO,0min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",['cwe:546']
AZHFJ_KMTlwiQl6exESZ,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""data"" is ""struct input_kbd_matrix_common_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ_KMTlwiQl6exESa,c:S1116,Remove this empty statement.,Empty statements should be removed,"<h2>Why is this an issue?</h2>
<p>Empty statements represented by a semicolon <code>;</code> are statements that do not perform any operation. They are often the result of a typo or
a misunderstanding of the language syntax. It is a good practice to remove empty statements since they don’t add value and lead to confusion and
errors.</p>
<h3>Exceptions</h3>
<p>In the case of an empty expanded macro, the issue is not raised.</p>
<pre>
#define LOG(x)

void fun() {
  LOG(X);
}
</pre>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething() {
  ;                // Noncompliant - was used as a kind of TODO marker
}

#define A(x) x;    // Noncompliant - macro definitions should not end with a semi-colon when they are used as functions

void fun() {
  A(5);            // Noncompliant - after expansion, there are 2 consecutive semi-colons
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething() {
}

#define A(x) x

void fun() {
  A(5);
}
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that
  the first character following the null statement is a white-space character. </li>
  <li> MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided
  that the first character following the null statement is a white-space character. </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/WtYxBQ"">CERT, EXP15-C.</a> - Do not place a semicolon on the same line as an if, for, or while
  statement </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBKyTlwiQl6exGA-,c:S1172,"Remove the unused parameter ""arg1"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKBKyTlwiQl6exGA_,c:S1172,"Remove the unused parameter ""arg2"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKBKyTlwiQl6exGBA,c:S1172,"Remove the unused parameter ""arg3"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKBKyTlwiQl6exGBB,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""arg1"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBKyTlwiQl6exGBC,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""arg2"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBKyTlwiQl6exGBD,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""arg3"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKBKyTlwiQl6exGBE,c:S108,"Fill this compound statement, remove it, or add a nested comment explaining why it is empty.",Nested blocks of code should not be left empty,"<h2>Why is this an issue?</h2>
<p>An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.</p>
<pre>
void foo()
{
  int x;
  if (x == 42)
  // Noncompliant - the following nested block is empty
  {
  }
  else
  {
    doSomething();
  }
}
</pre>
<p>Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.</p>
<pre>
void foo()
{
  int x;
  if (x != 42)
  {
    doSomething();
  }
}
</pre>
<h3>Exceptions</h3>
<ul>
  <li> The rule ignores code blocks that contain comments. </li>
  <li> Functions are not nested blocks, so they can be empty. </li>
</ul>
<pre>
void bar()
// Compliant - functions are not nested blocks
{
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKHsSTlwiQl6exQf-,c:S886,Refactor this loop so that it is less error-prone.,"The three expressions of a ""for"" statement should only be concerned with loop control","<h2>Why is this an issue?</h2>
<p><code>for</code> loops are very flexible in C and C++. Because of that, they can carry a complexity that can make the code error-prone, difficult
to understand, and hard to maintain.</p>
<p>Many for loops can be written in a way that clearly separates the iteration process from the content of the iteration. This rule makes sure that
all the code relevant to the iteration is placed in the for-loop header. The compliant code is then easier to reason about.</p>
<p>A for loop is composed of 4 sub-parts:</p>
<pre>
for([initialization]; [condition]; [update])
  [body]
</pre>
<p>We classify the variables used to control them in three categories:</p>
<ul>
  <li> A <em>loop-counter</em> is a variable modified in the update. It should not be modified in the body. </li>
  <li> A <em>loop-constant</em> is an auxiliary variable declared in the initialization. It’s very often used to precompute some data about the end
  condition or the stride. </li>
  <li> A <em>pseudo-counter</em> shares some properties with a loop counter, but its update conditions are more complex. It will therefore only be
  updated in the body, and cannot be used in the update. Using a pseudo-counter makes the loop more complex to reason about, and therefore is not
  permitted. They are very often declared in the initialization, for instance, to limit their scope, but in some cases reuse existing variables. </li>
</ul>
<p>Additionally, the loop condition should refer to at least one <em>loop-counter</em>, and should not modify anything.</p>
<p>This rule is only checking for loops with a condition and an update.</p>
<h3>Noncompliant code example</h3>
<pre>
for( int h = 0, int i = 0 ; h &lt; 10 ; i += 1 ) { // Noncompliant, the loop-counter is not used in the condition
}

for( int i = 0 ; i++ &lt; 10 ; i += 1 ) { // Noncompliant, loop-counter i is updated in the condition
}

for( int i = 0 , int h = 0; i+(++h) &lt; 10 ; i += 1 ) { // Noncompliant, pseudo-counter h is updated in the condition
}

for( int i = 0 ; i &lt; 10 ; i += 1 ) { // Noncompliant, loop-counter i is updated in the body
  if (i%2)  { ++i;}
}

for( int i = 0 , j = 0 ; i &lt; 10 ; i += j) { // Noncompliant, pseudo-counter j is is used in the update
  j = i + 1;
}

for( int i = 0 , j = 0 ; i &lt; 10 + j ; i += 1) { // Noncompliant, pseudo-counter j is is used in the condition
  j = i + 1;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 13.5 - The three expressions of a for statement shall be concerned only with loop control. </li>
  <li> MISRA C++:2008, 6-5-5 - A <em>loop-control-variable</em> other than the <em>loop-counter</em> shall not be modified within <em>condition</em>
  or <em>expression</em>. </li>
  <li> MISRA C:2012, 14.2 - A for loop shall be well-formed </li>
</ul>",MINOR,10min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKHksTlwiQl6exQbb,c:S924,"Reduce the number of nested ""break"" statements from 4 to 1 authorized.","Loops should not have more than one ""break"" or ""goto"" statement","<h2>Why is this an issue?</h2>
<p>Restricting the number of exits from a loop is done in the interests of good structured programming. One <code>break</code> or <code>goto</code>
statement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.</p>
<h3>Noncompliant code example</h3>
<p>With the default threshold of 1:</p>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
  else if (...) {
    break;      //  Non-compliant - second jump from loop
  }
  else {
    ...
  }
}
while (...) {
  if (...) {
    break;      // Compliant
  }
  if (...) {
    break;      // Non-compliant - second jump from loop
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
for (int i = 0; i &lt; 10; i++) {
  if (...) {
    break;      //  Compliant
  }
}
while (...) {
  if (...) {
    break;    // Compliant
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. </li>
  <li> MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. </li>
  <li> MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement </li>
</ul>",MAJOR,20min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKHksTlwiQl6exQbc,c:S1172,"Remove the unused parameter ""args"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKF6OTlwiQl6exOI6,c:S3776,Refactor this function to reduce its Cognitive Complexity from 107 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKF6OTlwiQl6exOI7,c:S134,Refactor this code to not nest more than 3 if|for|do|while|switch statements.,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","<h2>Why is this an issue?</h2>
<p>Nested control flow statements <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> are
often key ingredients in creating what’s known as ""Spaghetti code"". This code smell can make your program difficult to understand and maintain.</p>
<p>When numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s
readability and maintainability, and it also complicates the testing process.</p>
<h3>Exceptions</h3>
<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow
statement.</p>
<pre>
  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)

  if (condition1) {       // Compliant; depth = 1
    if (condition2) {     // Compliant; depth = 2
      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)
        if (condition3) {   // Noncompliant; depth = 4
          /* ... */
        }
      }
    }
  }
</pre>
<h2>How to fix it</h2>
<h3>Code examples</h3>
<p>The following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix
the code smell by introducing guard clauses:</p>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
if (condition1) {                  // Compliant - depth = 1
  /* ... */
  if (condition2) {                // Compliant - depth = 2
    /* ... */
    for (int i = 0; i &lt; 10; i++) {  // Compliant - depth = 3
      /* ... */
      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit
        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4
          /* ... */
        }
        return;
      }
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
if (!condition1) {
  return;
}
/* ... */
if (!condition2) {
  return;
}
for (int i = 0; i &lt; 10; i++) {
  /* ... */
  if (condition4) {
    if (condition5) {
      /* ... */
    }
    return;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href=""https://en.wikipedia.org/wiki/Guard_(computer_science)"">Guard clauses in programming</a> - one of the approaches to reducing the depth
  of nesting </li>
</ul>",CRITICAL,10min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKF4OTlwiQl6exOHD,c:S3776,Refactor this function to reduce its Cognitive Complexity from 40 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKF4OTlwiQl6exOHG,c:S3776,Refactor this function to reduce its Cognitive Complexity from 54 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ-KGTlwiQl6exDh-,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-KGTlwiQl6exDh_,c:S1172,"Remove the unused parameter ""sys"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-KGTlwiQl6exDiA,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-KGTlwiQl6exDiB,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-KGTlwiQl6exDiC,c:S1172,"Remove the unused parameter ""sys"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-KGTlwiQl6exDiD,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-KGTlwiQl6exDiE,c:S1172,"Remove the unused parameter ""sys"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-KGTlwiQl6exDiF,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-KGTlwiQl6exDh9,c:S1135,"Complete the task associated to this ""TODO"" comment.","Track uses of ""TODO"" tags","<h2>Why is this an issue?</h2>
<p>Developers often use <code>TODO</code> tags to mark areas in the code where additional work or improvements are needed but are not implemented
immediately. However, these <code>TODO</code> tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to
identify and address unattended <code>TODO</code> tags to ensure a clean and maintainable codebase. This description explores why this is a problem
and how it can be fixed to improve the overall code quality.</p>
<h3>What is the potential impact?</h3>
<p>Unattended <code>TODO</code> tags in code can have significant implications for the development process and the overall codebase.</p>
<p>Incomplete Functionality: When developers leave <code>TODO</code> tags without implementing the corresponding code, it results in incomplete
functionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.</p>
<p>Missed Bug Fixes: If developers do not promptly address <code>TODO</code> tags, they might overlook critical bug fixes and security updates.
Delayed bug fixes can result in more severe issues and increase the effort required to resolve them later.</p>
<p>Impact on Collaboration: In team-based development environments, unattended <code>TODO</code> tags can hinder collaboration. Other team members
might not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.</p>
<p>Codebase Bloat: The accumulation of unattended <code>TODO</code> tags over time can clutter the codebase and make it difficult to distinguish
between work in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.</p>
<p>Addressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among
developers.</p>
<h3>Noncompliant code example</h3>
<pre>
void foo() {
  // TODO
}
</pre>
<h2>Resources</h2>
<ul>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/546"">CWE-546 - Suspicious Comment</a> </li>
</ul>",INFO,0min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",['cwe:546']
AZHFJ-NqTlwiQl6exDlE,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-NqTlwiQl6exDlF,c:S1172,"Remove the unused parameter ""sys"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-NqTlwiQl6exDlG,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-NqTlwiQl6exDlH,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-NqTlwiQl6exDlI,c:S1172,"Remove the unused parameter ""sys"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-NqTlwiQl6exDlJ,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-NqTlwiQl6exDlK,c:S1172,"Remove the unused parameter ""sys"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-NqTlwiQl6exDlL,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-MBTlwiQl6exDjx,c:S1135,"Complete the task associated to this ""TODO"" comment.","Track uses of ""TODO"" tags","<h2>Why is this an issue?</h2>
<p>Developers often use <code>TODO</code> tags to mark areas in the code where additional work or improvements are needed but are not implemented
immediately. However, these <code>TODO</code> tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to
identify and address unattended <code>TODO</code> tags to ensure a clean and maintainable codebase. This description explores why this is a problem
and how it can be fixed to improve the overall code quality.</p>
<h3>What is the potential impact?</h3>
<p>Unattended <code>TODO</code> tags in code can have significant implications for the development process and the overall codebase.</p>
<p>Incomplete Functionality: When developers leave <code>TODO</code> tags without implementing the corresponding code, it results in incomplete
functionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.</p>
<p>Missed Bug Fixes: If developers do not promptly address <code>TODO</code> tags, they might overlook critical bug fixes and security updates.
Delayed bug fixes can result in more severe issues and increase the effort required to resolve them later.</p>
<p>Impact on Collaboration: In team-based development environments, unattended <code>TODO</code> tags can hinder collaboration. Other team members
might not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.</p>
<p>Codebase Bloat: The accumulation of unattended <code>TODO</code> tags over time can clutter the codebase and make it difficult to distinguish
between work in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.</p>
<p>Addressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among
developers.</p>
<h3>Noncompliant code example</h3>
<pre>
void foo() {
  // TODO
}
</pre>
<h2>Resources</h2>
<ul>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/546"">CWE-546 - Suspicious Comment</a> </li>
</ul>",INFO,0min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",['cwe:546']
AZHFJ-MBTlwiQl6exDj0,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-MBTlwiQl6exDjy,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-MBTlwiQl6exDjz,c:S1172,"Remove the unused parameter ""sys"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-MBTlwiQl6exDj1,c:S1172,"Remove the unused parameter ""sys"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-MBTlwiQl6exDj2,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-MBTlwiQl6exDj3,c:S5350,"Make the type of this variable a pointer-to-const. The current type of ""data"" is ""struct clock_control_si32_pll_data *"".","Pointer and reference local variables should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h3>Noncompliant code example</h3>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-MBTlwiQl6exDj4,c:S1172,"Remove the unused parameter ""sys"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-MBTlwiQl6exDj5,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""sys"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-MBTlwiQl6exDj6,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""rate_"" is ""void *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ-85TlwiQl6exEGi,c:S108,"Fill this compound statement, remove it, or add a nested comment explaining why it is empty.",Nested blocks of code should not be left empty,"<h2>Why is this an issue?</h2>
<p>An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.</p>
<pre>
void foo()
{
  int x;
  if (x == 42)
  // Noncompliant - the following nested block is empty
  {
  }
  else
  {
    doSomething();
  }
}
</pre>
<p>Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.</p>
<pre>
void foo()
{
  int x;
  if (x != 42)
  {
    doSomething();
  }
}
</pre>
<h3>Exceptions</h3>
<ul>
  <li> The rule ignores code blocks that contain comments. </li>
  <li> Functions are not nested blocks, so they can be empty. </li>
</ul>
<pre>
void bar()
// Compliant - functions are not nested blocks
{
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-85TlwiQl6exEGj,c:S108,"Fill this compound statement, remove it, or add a nested comment explaining why it is empty.",Nested blocks of code should not be left empty,"<h2>Why is this an issue?</h2>
<p>An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.</p>
<pre>
void foo()
{
  int x;
  if (x == 42)
  // Noncompliant - the following nested block is empty
  {
  }
  else
  {
    doSomething();
  }
}
</pre>
<p>Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.</p>
<pre>
void foo()
{
  int x;
  if (x != 42)
  {
    doSomething();
  }
}
</pre>
<h3>Exceptions</h3>
<ul>
  <li> The rule ignores code blocks that contain comments. </li>
  <li> Functions are not nested blocks, so they can be empty. </li>
</ul>
<pre>
void bar()
// Compliant - functions are not nested blocks
{
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ-85TlwiQl6exEGk,c:S108,"Fill this compound statement, remove it, or add a nested comment explaining why it is empty.",Nested blocks of code should not be left empty,"<h2>Why is this an issue?</h2>
<p>An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.</p>
<pre>
void foo()
{
  int x;
  if (x == 42)
  // Noncompliant - the following nested block is empty
  {
  }
  else
  {
    doSomething();
  }
}
</pre>
<p>Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.</p>
<pre>
void foo()
{
  int x;
  if (x != 42)
  {
    doSomething();
  }
}
</pre>
<h3>Exceptions</h3>
<ul>
  <li> The rule ignores code blocks that contain comments. </li>
  <li> Functions are not nested blocks, so they can be empty. </li>
</ul>
<pre>
void bar()
// Compliant - functions are not nested blocks
{
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9FSTlwiQl6exC4u,c:S108,"Fill this compound statement, remove it, or add a nested comment explaining why it is empty.",Nested blocks of code should not be left empty,"<h2>Why is this an issue?</h2>
<p>An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.</p>
<pre>
void foo()
{
  int x;
  if (x == 42)
  // Noncompliant - the following nested block is empty
  {
  }
  else
  {
    doSomething();
  }
}
</pre>
<p>Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.</p>
<pre>
void foo()
{
  int x;
  if (x != 42)
  {
    doSomething();
  }
}
</pre>
<h3>Exceptions</h3>
<ul>
  <li> The rule ignores code blocks that contain comments. </li>
  <li> Functions are not nested blocks, so they can be empty. </li>
</ul>
<pre>
void bar()
// Compliant - functions are not nested blocks
{
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ_27TlwiQl6exExR,python:S112,Replace this generic exception class with a more specific one.,"""Exception"" and ""BaseException"" should not be raised","<p>This rule raises an issue when a generic exception (such as <code>Exception</code> or <code>BaseException</code>) is raised.</p>
<h2>Why is this an issue?</h2>
<p>Raising instances of <a href=""https://docs.python.org/3/library/exceptions.html#Exception""><code>Exception</code></a> and <a
href=""https://docs.python.org/3/library/exceptions.html#BaseException""><code>BaseException</code></a> will have a negative impact on any code trying
to catch these exceptions.</p>
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.</p>
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
<p>For instance, if an exception such as <code>SystemExit</code> is caught and not re-raised, it will prevent the program from stopping.</p>
<p>When raising an exception, it is therefore recommended to raising the most specific exception possible so that it can be handled intentionally by
consumers.</p>
<h2>How to fix it</h2>
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
<ul>
  <li> Raise a specific <a href=""https://docs.python.org/3/library/exceptions.html"">Built-in exception</a> when one matches. For example
  <code>TypeError</code> should be raised when the type of a parameter is not the one expected. </li>
  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>
</ul>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def check_value(value):
    if value &lt; 0:
        raise BaseException(""Value cannot be negative"") # Noncompliant: this will be difficult for consumers to handle
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def check_value(value):
    if value &lt; 0:
        raise ValueError(""Value cannot be negative"") # Compliant
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Python Documentation - <a href=""https://docs.python.org/3/library/exceptions.html#BaseException"">Built-in exceptions</a> </li>
  <li> PEP 352 - <a href=""https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes"">Required Superclass for Exceptions</a> </li>
</ul>",MAJOR,20min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:397']
AZHFJ_27TlwiQl6exExS,python:S112,Replace this generic exception class with a more specific one.,"""Exception"" and ""BaseException"" should not be raised","<p>This rule raises an issue when a generic exception (such as <code>Exception</code> or <code>BaseException</code>) is raised.</p>
<h2>Why is this an issue?</h2>
<p>Raising instances of <a href=""https://docs.python.org/3/library/exceptions.html#Exception""><code>Exception</code></a> and <a
href=""https://docs.python.org/3/library/exceptions.html#BaseException""><code>BaseException</code></a> will have a negative impact on any code trying
to catch these exceptions.</p>
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.</p>
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
<p>For instance, if an exception such as <code>SystemExit</code> is caught and not re-raised, it will prevent the program from stopping.</p>
<p>When raising an exception, it is therefore recommended to raising the most specific exception possible so that it can be handled intentionally by
consumers.</p>
<h2>How to fix it</h2>
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
<ul>
  <li> Raise a specific <a href=""https://docs.python.org/3/library/exceptions.html"">Built-in exception</a> when one matches. For example
  <code>TypeError</code> should be raised when the type of a parameter is not the one expected. </li>
  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>
</ul>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def check_value(value):
    if value &lt; 0:
        raise BaseException(""Value cannot be negative"") # Noncompliant: this will be difficult for consumers to handle
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def check_value(value):
    if value &lt; 0:
        raise ValueError(""Value cannot be negative"") # Compliant
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Python Documentation - <a href=""https://docs.python.org/3/library/exceptions.html#BaseException"">Built-in exceptions</a> </li>
  <li> PEP 352 - <a href=""https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes"">Required Superclass for Exceptions</a> </li>
</ul>",MAJOR,20min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:397']
AZHFJ_27TlwiQl6exExT,python:S112,Replace this generic exception class with a more specific one.,"""Exception"" and ""BaseException"" should not be raised","<p>This rule raises an issue when a generic exception (such as <code>Exception</code> or <code>BaseException</code>) is raised.</p>
<h2>Why is this an issue?</h2>
<p>Raising instances of <a href=""https://docs.python.org/3/library/exceptions.html#Exception""><code>Exception</code></a> and <a
href=""https://docs.python.org/3/library/exceptions.html#BaseException""><code>BaseException</code></a> will have a negative impact on any code trying
to catch these exceptions.</p>
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.</p>
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
<p>For instance, if an exception such as <code>SystemExit</code> is caught and not re-raised, it will prevent the program from stopping.</p>
<p>When raising an exception, it is therefore recommended to raising the most specific exception possible so that it can be handled intentionally by
consumers.</p>
<h2>How to fix it</h2>
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
<ul>
  <li> Raise a specific <a href=""https://docs.python.org/3/library/exceptions.html"">Built-in exception</a> when one matches. For example
  <code>TypeError</code> should be raised when the type of a parameter is not the one expected. </li>
  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>
</ul>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def check_value(value):
    if value &lt; 0:
        raise BaseException(""Value cannot be negative"") # Noncompliant: this will be difficult for consumers to handle
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def check_value(value):
    if value &lt; 0:
        raise ValueError(""Value cannot be negative"") # Compliant
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Python Documentation - <a href=""https://docs.python.org/3/library/exceptions.html#BaseException"">Built-in exceptions</a> </li>
  <li> PEP 352 - <a href=""https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes"">Required Superclass for Exceptions</a> </li>
</ul>",MAJOR,20min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:397']
AZHFJ_27TlwiQl6exExU,python:S112,Replace this generic exception class with a more specific one.,"""Exception"" and ""BaseException"" should not be raised","<p>This rule raises an issue when a generic exception (such as <code>Exception</code> or <code>BaseException</code>) is raised.</p>
<h2>Why is this an issue?</h2>
<p>Raising instances of <a href=""https://docs.python.org/3/library/exceptions.html#Exception""><code>Exception</code></a> and <a
href=""https://docs.python.org/3/library/exceptions.html#BaseException""><code>BaseException</code></a> will have a negative impact on any code trying
to catch these exceptions.</p>
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.</p>
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
<p>For instance, if an exception such as <code>SystemExit</code> is caught and not re-raised, it will prevent the program from stopping.</p>
<p>When raising an exception, it is therefore recommended to raising the most specific exception possible so that it can be handled intentionally by
consumers.</p>
<h2>How to fix it</h2>
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
<ul>
  <li> Raise a specific <a href=""https://docs.python.org/3/library/exceptions.html"">Built-in exception</a> when one matches. For example
  <code>TypeError</code> should be raised when the type of a parameter is not the one expected. </li>
  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>
</ul>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def check_value(value):
    if value &lt; 0:
        raise BaseException(""Value cannot be negative"") # Noncompliant: this will be difficult for consumers to handle
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def check_value(value):
    if value &lt; 0:
        raise ValueError(""Value cannot be negative"") # Compliant
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Python Documentation - <a href=""https://docs.python.org/3/library/exceptions.html#BaseException"">Built-in exceptions</a> </li>
  <li> PEP 352 - <a href=""https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes"">Required Superclass for Exceptions</a> </li>
</ul>",MAJOR,20min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:397']
AZHFJ_27TlwiQl6exExV,python:S3776,Refactor this function to reduce its Cognitive Complexity from 29 to the 15 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 5.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def process_eligible_users(users):
    for user in users:             # +1 (for)
        if ((user.is_active and    # +1 (if) +1 (nested) +1 (multiple conditions)
            user.has_profile) or   # +1 (mixed operator)
            user.age &gt; 18 ):
            user.process()
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>process_eligible_users</code> function, which now only has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def process_eligible_users(users):
    for user in users:             # +1 (for)
        if is_eligible_user(user): # +1 (if) +1 (nested)
            user.process()

def is_eligible_user(user):
    return ((user.is_active and user.has_profile) or user.age &gt; 18) # +1 (multiple conditions) +1 (mixed operators)
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p><em>Note:</em> The code is simplified here, to illustrate the purpose. Please imagine there is more happening in the process.<br></p>
<p>The bellow code has a cognitive complexity score of 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
def process_user(user):
    if user.is_active():             # +1 (if)
        if user.has_profile():       # +1 (if) +1 (nested)
            ... # process active user with profile
        else:                        # +1 (else)
            ... # process active user without profile
    else:                            # +1 (else)
        if user.has_profile():       # +1 (if) +1 (nested)
            ... # process inactive user with profile
        else:                        # +1 (else)
            ... # process inactive user without profile
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions and the breaks in flow are no more
nested.<br> The <code>process_user</code> has now a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
def process_user(user):
    if user.is_active():             # +1 (if)
        process_active_user(user)
    else:                            # +1 (else)
        process_inactive_user(user)

def process_active_user(user):
    if user.has_profile():           # +1 (if) +1 (nested)
        ... # process active user with profile
    else:                            # +1 (else)
        ... # process active user without profile

def process_inactive_user(user):
    if user.has_profile():           # +1 (if) +1 (nested)
        ... # process inactive user with profile
    else:                            # +1 (else)
        ... # process inactive user without profile
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 6.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
def calculate(data):
    if data is not None:  # +1 (if)
        total = 0
        for item in data: # +1 (for) +1 (nested)
            if item &gt; 0:  # +1 (if)  +2 (nested)
                total += item * 2
        return total
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 4.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
def calculate(data):
    if data is None:      # +1 (if)
        return None
    total = 0
    for item in data:     # +1 (for)
        if item &gt; 0:      # +1 (if) +1 (nested)
            total += item * 2
    return total
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ_27TlwiQl6exExW,python:S112,Replace this generic exception class with a more specific one.,"""Exception"" and ""BaseException"" should not be raised","<p>This rule raises an issue when a generic exception (such as <code>Exception</code> or <code>BaseException</code>) is raised.</p>
<h2>Why is this an issue?</h2>
<p>Raising instances of <a href=""https://docs.python.org/3/library/exceptions.html#Exception""><code>Exception</code></a> and <a
href=""https://docs.python.org/3/library/exceptions.html#BaseException""><code>BaseException</code></a> will have a negative impact on any code trying
to catch these exceptions.</p>
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.</p>
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
<p>For instance, if an exception such as <code>SystemExit</code> is caught and not re-raised, it will prevent the program from stopping.</p>
<p>When raising an exception, it is therefore recommended to raising the most specific exception possible so that it can be handled intentionally by
consumers.</p>
<h2>How to fix it</h2>
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
<ul>
  <li> Raise a specific <a href=""https://docs.python.org/3/library/exceptions.html"">Built-in exception</a> when one matches. For example
  <code>TypeError</code> should be raised when the type of a parameter is not the one expected. </li>
  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>
</ul>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def check_value(value):
    if value &lt; 0:
        raise BaseException(""Value cannot be negative"") # Noncompliant: this will be difficult for consumers to handle
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def check_value(value):
    if value &lt; 0:
        raise ValueError(""Value cannot be negative"") # Compliant
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Python Documentation - <a href=""https://docs.python.org/3/library/exceptions.html#BaseException"">Built-in exceptions</a> </li>
  <li> PEP 352 - <a href=""https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes"">Required Superclass for Exceptions</a> </li>
</ul>",MAJOR,20min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:397']
AZHFJ_27TlwiQl6exExX,python:S112,Replace this generic exception class with a more specific one.,"""Exception"" and ""BaseException"" should not be raised","<p>This rule raises an issue when a generic exception (such as <code>Exception</code> or <code>BaseException</code>) is raised.</p>
<h2>Why is this an issue?</h2>
<p>Raising instances of <a href=""https://docs.python.org/3/library/exceptions.html#Exception""><code>Exception</code></a> and <a
href=""https://docs.python.org/3/library/exceptions.html#BaseException""><code>BaseException</code></a> will have a negative impact on any code trying
to catch these exceptions.</p>
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.</p>
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
<p>For instance, if an exception such as <code>SystemExit</code> is caught and not re-raised, it will prevent the program from stopping.</p>
<p>When raising an exception, it is therefore recommended to raising the most specific exception possible so that it can be handled intentionally by
consumers.</p>
<h2>How to fix it</h2>
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
<ul>
  <li> Raise a specific <a href=""https://docs.python.org/3/library/exceptions.html"">Built-in exception</a> when one matches. For example
  <code>TypeError</code> should be raised when the type of a parameter is not the one expected. </li>
  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>
</ul>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def check_value(value):
    if value &lt; 0:
        raise BaseException(""Value cannot be negative"") # Noncompliant: this will be difficult for consumers to handle
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def check_value(value):
    if value &lt; 0:
        raise ValueError(""Value cannot be negative"") # Compliant
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Python Documentation - <a href=""https://docs.python.org/3/library/exceptions.html#BaseException"">Built-in exceptions</a> </li>
  <li> PEP 352 - <a href=""https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes"">Required Superclass for Exceptions</a> </li>
</ul>",MAJOR,20min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:397']
AZHFJ_27TlwiQl6exExY,python:S112,Replace this generic exception class with a more specific one.,"""Exception"" and ""BaseException"" should not be raised","<p>This rule raises an issue when a generic exception (such as <code>Exception</code> or <code>BaseException</code>) is raised.</p>
<h2>Why is this an issue?</h2>
<p>Raising instances of <a href=""https://docs.python.org/3/library/exceptions.html#Exception""><code>Exception</code></a> and <a
href=""https://docs.python.org/3/library/exceptions.html#BaseException""><code>BaseException</code></a> will have a negative impact on any code trying
to catch these exceptions.</p>
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.</p>
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
<p>For instance, if an exception such as <code>SystemExit</code> is caught and not re-raised, it will prevent the program from stopping.</p>
<p>When raising an exception, it is therefore recommended to raising the most specific exception possible so that it can be handled intentionally by
consumers.</p>
<h2>How to fix it</h2>
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
<ul>
  <li> Raise a specific <a href=""https://docs.python.org/3/library/exceptions.html"">Built-in exception</a> when one matches. For example
  <code>TypeError</code> should be raised when the type of a parameter is not the one expected. </li>
  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>
</ul>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def check_value(value):
    if value &lt; 0:
        raise BaseException(""Value cannot be negative"") # Noncompliant: this will be difficult for consumers to handle
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def check_value(value):
    if value &lt; 0:
        raise ValueError(""Value cannot be negative"") # Compliant
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Python Documentation - <a href=""https://docs.python.org/3/library/exceptions.html#BaseException"">Built-in exceptions</a> </li>
  <li> PEP 352 - <a href=""https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes"">Required Superclass for Exceptions</a> </li>
</ul>",MAJOR,20min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:397']
AZHFJ_27TlwiQl6exExZ,python:S108,Either remove or fill this block of code.,Nested blocks of code should not be left empty,"<h2>Why is this an issue?</h2>
<p>An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.</p>
<pre>
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
    pass
</pre>
<p>Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.</p>
<h3>Exceptions</h3>
<p>The rule ignores code blocks that contain comments.</p>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ_27TlwiQl6exExa,python:S112,Replace this generic exception class with a more specific one.,"""Exception"" and ""BaseException"" should not be raised","<p>This rule raises an issue when a generic exception (such as <code>Exception</code> or <code>BaseException</code>) is raised.</p>
<h2>Why is this an issue?</h2>
<p>Raising instances of <a href=""https://docs.python.org/3/library/exceptions.html#Exception""><code>Exception</code></a> and <a
href=""https://docs.python.org/3/library/exceptions.html#BaseException""><code>BaseException</code></a> will have a negative impact on any code trying
to catch these exceptions.</p>
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.</p>
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
<p>For instance, if an exception such as <code>SystemExit</code> is caught and not re-raised, it will prevent the program from stopping.</p>
<p>When raising an exception, it is therefore recommended to raising the most specific exception possible so that it can be handled intentionally by
consumers.</p>
<h2>How to fix it</h2>
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
<ul>
  <li> Raise a specific <a href=""https://docs.python.org/3/library/exceptions.html"">Built-in exception</a> when one matches. For example
  <code>TypeError</code> should be raised when the type of a parameter is not the one expected. </li>
  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>
</ul>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def check_value(value):
    if value &lt; 0:
        raise BaseException(""Value cannot be negative"") # Noncompliant: this will be difficult for consumers to handle
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def check_value(value):
    if value &lt; 0:
        raise ValueError(""Value cannot be negative"") # Compliant
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Python Documentation - <a href=""https://docs.python.org/3/library/exceptions.html#BaseException"">Built-in exceptions</a> </li>
  <li> PEP 352 - <a href=""https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes"">Required Superclass for Exceptions</a> </li>
</ul>",MAJOR,20min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:397']
AZHFJ_27TlwiQl6exExb,python:S108,Either remove or fill this block of code.,Nested blocks of code should not be left empty,"<h2>Why is this an issue?</h2>
<p>An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is
incomplete.</p>
<pre>
# Noncompliant: is the block empty on purpose, or is code missing?
for i in range(3):
    pass
</pre>
<p>Removing or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.</p>
<h3>Exceptions</h3>
<p>The rule ignores code blocks that contain comments.</p>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ_27TlwiQl6exExc,python:S112,Replace this generic exception class with a more specific one.,"""Exception"" and ""BaseException"" should not be raised","<p>This rule raises an issue when a generic exception (such as <code>Exception</code> or <code>BaseException</code>) is raised.</p>
<h2>Why is this an issue?</h2>
<p>Raising instances of <a href=""https://docs.python.org/3/library/exceptions.html#Exception""><code>Exception</code></a> and <a
href=""https://docs.python.org/3/library/exceptions.html#BaseException""><code>BaseException</code></a> will have a negative impact on any code trying
to catch these exceptions.</p>
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.</p>
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
<p>For instance, if an exception such as <code>SystemExit</code> is caught and not re-raised, it will prevent the program from stopping.</p>
<p>When raising an exception, it is therefore recommended to raising the most specific exception possible so that it can be handled intentionally by
consumers.</p>
<h2>How to fix it</h2>
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
<ul>
  <li> Raise a specific <a href=""https://docs.python.org/3/library/exceptions.html"">Built-in exception</a> when one matches. For example
  <code>TypeError</code> should be raised when the type of a parameter is not the one expected. </li>
  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>
</ul>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def check_value(value):
    if value &lt; 0:
        raise BaseException(""Value cannot be negative"") # Noncompliant: this will be difficult for consumers to handle
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def check_value(value):
    if value &lt; 0:
        raise ValueError(""Value cannot be negative"") # Compliant
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Python Documentation - <a href=""https://docs.python.org/3/library/exceptions.html#BaseException"">Built-in exceptions</a> </li>
  <li> PEP 352 - <a href=""https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes"">Required Superclass for Exceptions</a> </li>
</ul>",MAJOR,20min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:397']
AZHFJ_27TlwiQl6exExd,python:S3776,Refactor this function to reduce its Cognitive Complexity from 27 to the 15 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 5.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def process_eligible_users(users):
    for user in users:             # +1 (for)
        if ((user.is_active and    # +1 (if) +1 (nested) +1 (multiple conditions)
            user.has_profile) or   # +1 (mixed operator)
            user.age &gt; 18 ):
            user.process()
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>process_eligible_users</code> function, which now only has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def process_eligible_users(users):
    for user in users:             # +1 (for)
        if is_eligible_user(user): # +1 (if) +1 (nested)
            user.process()

def is_eligible_user(user):
    return ((user.is_active and user.has_profile) or user.age &gt; 18) # +1 (multiple conditions) +1 (mixed operators)
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p><em>Note:</em> The code is simplified here, to illustrate the purpose. Please imagine there is more happening in the process.<br></p>
<p>The bellow code has a cognitive complexity score of 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
def process_user(user):
    if user.is_active():             # +1 (if)
        if user.has_profile():       # +1 (if) +1 (nested)
            ... # process active user with profile
        else:                        # +1 (else)
            ... # process active user without profile
    else:                            # +1 (else)
        if user.has_profile():       # +1 (if) +1 (nested)
            ... # process inactive user with profile
        else:                        # +1 (else)
            ... # process inactive user without profile
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions and the breaks in flow are no more
nested.<br> The <code>process_user</code> has now a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
def process_user(user):
    if user.is_active():             # +1 (if)
        process_active_user(user)
    else:                            # +1 (else)
        process_inactive_user(user)

def process_active_user(user):
    if user.has_profile():           # +1 (if) +1 (nested)
        ... # process active user with profile
    else:                            # +1 (else)
        ... # process active user without profile

def process_inactive_user(user):
    if user.has_profile():           # +1 (if) +1 (nested)
        ... # process inactive user with profile
    else:                            # +1 (else)
        ... # process inactive user without profile
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 6.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
def calculate(data):
    if data is not None:  # +1 (if)
        total = 0
        for item in data: # +1 (for) +1 (nested)
            if item &gt; 0:  # +1 (if)  +2 (nested)
                total += item * 2
        return total
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 4.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
def calculate(data):
    if data is None:      # +1 (if)
        return None
    total = 0
    for item in data:     # +1 (for)
        if item &gt; 0:      # +1 (if) +1 (nested)
            total += item * 2
    return total
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ_27TlwiQl6exExe,python:S112,Replace this generic exception class with a more specific one.,"""Exception"" and ""BaseException"" should not be raised","<p>This rule raises an issue when a generic exception (such as <code>Exception</code> or <code>BaseException</code>) is raised.</p>
<h2>Why is this an issue?</h2>
<p>Raising instances of <a href=""https://docs.python.org/3/library/exceptions.html#Exception""><code>Exception</code></a> and <a
href=""https://docs.python.org/3/library/exceptions.html#BaseException""><code>BaseException</code></a> will have a negative impact on any code trying
to catch these exceptions.</p>
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.</p>
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
<p>For instance, if an exception such as <code>SystemExit</code> is caught and not re-raised, it will prevent the program from stopping.</p>
<p>When raising an exception, it is therefore recommended to raising the most specific exception possible so that it can be handled intentionally by
consumers.</p>
<h2>How to fix it</h2>
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
<ul>
  <li> Raise a specific <a href=""https://docs.python.org/3/library/exceptions.html"">Built-in exception</a> when one matches. For example
  <code>TypeError</code> should be raised when the type of a parameter is not the one expected. </li>
  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>
</ul>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def check_value(value):
    if value &lt; 0:
        raise BaseException(""Value cannot be negative"") # Noncompliant: this will be difficult for consumers to handle
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def check_value(value):
    if value &lt; 0:
        raise ValueError(""Value cannot be negative"") # Compliant
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Python Documentation - <a href=""https://docs.python.org/3/library/exceptions.html#BaseException"">Built-in exceptions</a> </li>
  <li> PEP 352 - <a href=""https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes"">Required Superclass for Exceptions</a> </li>
</ul>",MAJOR,20min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:397']
AZHFJ_27TlwiQl6exExf,python:S112,Replace this generic exception class with a more specific one.,"""Exception"" and ""BaseException"" should not be raised","<p>This rule raises an issue when a generic exception (such as <code>Exception</code> or <code>BaseException</code>) is raised.</p>
<h2>Why is this an issue?</h2>
<p>Raising instances of <a href=""https://docs.python.org/3/library/exceptions.html#Exception""><code>Exception</code></a> and <a
href=""https://docs.python.org/3/library/exceptions.html#BaseException""><code>BaseException</code></a> will have a negative impact on any code trying
to catch these exceptions.</p>
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be
caught and let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers
to catch exceptions they do not intend to handle, which they then have to re-raise.</p>
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is
error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
<p>For instance, if an exception such as <code>SystemExit</code> is caught and not re-raised, it will prevent the program from stopping.</p>
<p>When raising an exception, it is therefore recommended to raising the most specific exception possible so that it can be handled intentionally by
consumers.</p>
<h2>How to fix it</h2>
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
<ul>
  <li> Raise a specific <a href=""https://docs.python.org/3/library/exceptions.html"">Built-in exception</a> when one matches. For example
  <code>TypeError</code> should be raised when the type of a parameter is not the one expected. </li>
  <li> Create a custom exception class deriving from <code>Exception</code> or one of its subclasses. </li>
</ul>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
def check_value(value):
    if value &lt; 0:
        raise BaseException(""Value cannot be negative"") # Noncompliant: this will be difficult for consumers to handle
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
def check_value(value):
    if value &lt; 0:
        raise ValueError(""Value cannot be negative"") # Compliant
</pre>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Python Documentation - <a href=""https://docs.python.org/3/library/exceptions.html#BaseException"">Built-in exceptions</a> </li>
  <li> PEP 352 - <a href=""https://www.python.org/dev/peps/pep-0352/#exception-hierarchy-changes"">Required Superclass for Exceptions</a> </li>
</ul>",MAJOR,20min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",['cwe:397']
AZHFKEBATlwiQl6exMNa,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""ctx"" is ""struct feedback_ctx *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKEBATlwiQl6exMNb,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""ctx"" is ""struct feedback_ctx *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKEBATlwiQl6exMNc,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""ctx"" is ""struct feedback_ctx *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKEBATlwiQl6exMNd,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""ctx"" is ""struct feedback_ctx *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKEBQTlwiQl6exMNi,c:S3646,Declare this variable in a separate statement.,Types and variables should be declared in separate statements,"<h2>Why is this an issue?</h2>
<p>It is possible in the same statement, to declare a user-defined type (<code>class</code>, <code>struct</code>, <code>union</code> or
<code>enum</code>) followed by variable declarations of this type. But mixing more than one concern in a single statement is confusing for
maintainers.</p>
<p>This rule raises an issue when a variable is declared at the end of a user-defined type declaration statement.</p>
<h3>Noncompliant code example</h3>
<pre>
struct Container { int size; } container; // Noncompliant
</pre>
<h3>Compliant solution</h3>
<pre>
struct Container { int size; };
Container container;
</pre>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement"">C.7: Don’t define a class or enum and declare a variable of its type in the same statement</a> </li>
</ul>",MINOR,2min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKEBQTlwiQl6exMNj,c:S1172,"Remove the unused parameter ""sof_cc"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKEBQTlwiQl6exMNk,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""ctx"" is ""struct feedback_ctx *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKEBQTlwiQl6exMNl,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""ctx"" is ""struct feedback_ctx *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKEBJTlwiQl6exMNe,c:S1172,"Remove the unused parameter ""dev"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKEBJTlwiQl6exMNf,c:S3776,Refactor this function to reduce its Cognitive Complexity from 34 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKEBJTlwiQl6exMNg,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKEBJTlwiQl6exMNh,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFKFyxTlwiQl6exN_d,c:S3776,Refactor this function to reduce its Cognitive Complexity from 89 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFxZTlwiQl6exN81,c:S3776,Refactor this function to reduce its Cognitive Complexity from 94 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFxZTlwiQl6exN83,c:S1066,"Merge this ""if"" statement with the enclosing one.","Mergeable ""if"" statements should be combined","<h2>Why is this an issue?</h2>
<p>Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as
possible, by avoiding unnecessary nesting, is considered a good practice.</p>
<p>Merging <code>if</code> statements when possible will decrease the nesting of the code and improve its readability.</p>
<p>Code like</p>
<pre>
if (condition1) {
  if (condition2) {             // Noncompliant
    /* ... */
  }
}
</pre>
<p>will be more readable as</p>
<pre>
if (condition1 &amp;&amp; condition2) { // Compliant
  /* ... */
}
</pre>
<h2>How to fix it</h2>
<p>If merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a
better approach to fix readability.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre>
if (fs::exists(path)) {
  if (fs::is_regular_file(path) || fs::is_directory(path)) { // Noncompliant
    /* ... */
  }
}
</pre>
<h4>Compliant solution</h4>
<pre>
bool isFileOrDirectory(fs::path const&amp; path) {
  return fs::is_regular_file(path) || fs::is_directory(path);
}

/* ... */

if (fs::exists(path) &amp;&amp; isFileOrDirectory(path)) { // Compliant
  /* ... */
}
</pre>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKFrlTlwiQl6exN1T,c:S3776,Refactor this function to reduce its Cognitive Complexity from 64 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKFHeTlwiQl6exNLO,c:S3776,Refactor this function to reduce its Cognitive Complexity from 50 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFJ8sXTlwiQl6exCnW,c:S1135,"Complete the task associated to this ""TODO"" comment.","Track uses of ""TODO"" tags","<h2>Why is this an issue?</h2>
<p>Developers often use <code>TODO</code> tags to mark areas in the code where additional work or improvements are needed but are not implemented
immediately. However, these <code>TODO</code> tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to
identify and address unattended <code>TODO</code> tags to ensure a clean and maintainable codebase. This description explores why this is a problem
and how it can be fixed to improve the overall code quality.</p>
<h3>What is the potential impact?</h3>
<p>Unattended <code>TODO</code> tags in code can have significant implications for the development process and the overall codebase.</p>
<p>Incomplete Functionality: When developers leave <code>TODO</code> tags without implementing the corresponding code, it results in incomplete
functionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.</p>
<p>Missed Bug Fixes: If developers do not promptly address <code>TODO</code> tags, they might overlook critical bug fixes and security updates.
Delayed bug fixes can result in more severe issues and increase the effort required to resolve them later.</p>
<p>Impact on Collaboration: In team-based development environments, unattended <code>TODO</code> tags can hinder collaboration. Other team members
might not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.</p>
<p>Codebase Bloat: The accumulation of unattended <code>TODO</code> tags over time can clutter the codebase and make it difficult to distinguish
between work in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.</p>
<p>Addressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among
developers.</p>
<h3>Noncompliant code example</h3>
<pre>
void foo() {
  // TODO
}
</pre>
<h2>Resources</h2>
<ul>
  <li> CWE - <a href=""https://cwe.mitre.org/data/definitions/546"">CWE-546 - Suspicious Comment</a> </li>
</ul>",INFO,0min,COMPLETE,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",['cwe:546']
AZHFJ9jbTlwiQl6exDJG,c:S1172,"Remove the unused parameter ""img_size"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFJ9jbTlwiQl6exDJH,c:S995,"Make the type of this parameter a pointer-to-const. The current type of ""img"" is ""unsigned char *"".","Pointer and reference parameters should be ""const"" if the corresponding object is not modified","<h2>Why is this an issue?</h2>
<p>Const correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for
maintainers.</p>
<p>Correctly const-qualifying pointers can be tricky because the indirection they add can also be const.</p>
<p>For a pointer <code>X * ptr</code>, const can be written in three different places:</p>
<ul>
  <li> <code>const X * ptr</code> and <code>X const * ptr</code> are identical and mean that the X object <code>ptr</code> points to cannot be
  changed. </li>
  <li> <code>X * const ptr</code> means that the pointer cannot be changed to point to a different X object. </li>
</ul>
<p>In a function signature, the first <code>const X * ptr</code> (or its equivalent <code>X const * ptr</code>) is the one that will bring
type-safety. It protects against changing the value pointed at.</p>
<pre>
void externalFunction(int * a, const int * b);

void myfunc() {
  int a = 1;
  int b = 2;
  externalFunction(&amp;a, &amp;b);
  // a can now have any value
  // We know that b is still '2'
}
</pre>
<p>This rule detects when a pointer or reference parameter could be made const</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
                   int * param3, // Noncompliant
             int * const param4) // Noncompliant: const doesn't qualify what is pointed at.
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                int &amp; increment) // Noncompliant
{
  value += increment;
}
</pre>
<p>When adding all possible <code>const</code> qualifications, we get:</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void myfunc (      int * param1,  // object is modified
             const int * param2,
             const int * param3,
             const int * param4)
{
  *param1 = *param2 + *param3 + *param4;
}

void increment (int &amp; value,
                const int &amp; increment)
{
  value += increment;
}
</pre>
<h2>Resources</h2>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> <a href=""https://isocpp.org/wiki/faq/const-correctness"">ISO C++ FAQ about const correctness</a>. </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify
  the addressed object. </li>
  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the
  corresponding object is not modified. </li>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>",MINOR,2min,CONVENTIONAL,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9jbTlwiQl6exDJI,c:S1659,Define each identifier in a dedicated statement.,Multiple variables should not be declared on the same line,"<h2>Why is this an issue?</h2>
<p>Declaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or
assignments, they become confusing for maintainers.</p>
<p>This rule raises an issue when a declaration declares multiple variables or members.</p>
<pre>
int i1, j1; // Noncompliant
int i2, *j2; // Noncompliant
int *i3,
    &amp;j3 = i2; // Noncompliant
</pre>
<p>Giving each declaration its own line makes the code more maintainable.</p>
<pre>
int i1;
int j1;
int i2;
int *j2;
int *i3;
int &amp;j3 = i2;
</pre>
<h2>Resources</h2>
<h3>Standards</h3>
<ul>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/EtcxBQ"">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>
</ul>
<h3>External coding guidelines</h3>
<ul>
  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator
  respectively </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration"">ES.10: Declare one
  name (only) per declaration</a> </li>
</ul>",MINOR,5min,FORMATTED,CONSISTENT,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9jbTlwiQl6exDJF,c:S5955,"Declare the variable ""i"" inside the loop.",Loop variables should be declared in the minimal possible scope,"<h2>Why is this an issue?</h2>
<p>When a loop variable is not used outside of a loop, it should be declared inside the loop declaration:</p>
<ul>
  <li> It improves readability. The scope of the variable is clearly defined. </li>
  <li> It reduces the number of mistakes. The variable can’t be accidentally misused outside of the loop. </li>
  <li> Resources are not retained longer than necessary. </li>
</ul>
<h3>Noncompliant code example</h3>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void f() {
  int i = 0; // Noncompliant: i is not used outside of the loop
  for (i = 0; i &lt; 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; std::endl;
  }
}
</pre>
<h3>Compliant solution</h3>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void f() {
  for (int i = 0; i &lt; 10; ++i) {
    std::cout &lt;&lt; i &lt;&lt; std::endl;
  }
}
</pre>
<h2>Resources</h2>
<ul>
  <li> C++ Core Guidelines - <a href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es5-keep-scopes-small"">ES.5: Keep
  scopes small</a> </li>
</ul>",MINOR,5min,MODULAR,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
AZHFJ9jbTlwiQl6exDJE,c:S959,Remove this #undef directive that undefines a non-existing macro.,"""#undef"" should be used with caution","<h2>Why is this an issue?</h2>
<p>Code that contains many macros becomes hard to understand. This is even worse when the set of defined macros is not stable, and you have to know at
each point what macros are defined. Therefore, <code>#undef</code> can decrease the readability of macros.</p>
<p>However, well-disciplined use of <code>#undef</code> can also improve readability, for instance when defining a macro with a limited scope: The
macro is <code>#defined</code>, used a couple of times to reduce code duplication, then immediately <code>#undefed</code>.</p>
<p>This rule raises an issue when a <code>#undef</code> undefines a macro that was defined in another file. It will also raise an issue for an
<code>#undef</code> directive that tries to undefine a non-existing macro.</p>
<h3>Noncompliant code example</h3>
<pre>
#ifndef MY_HDR
#define MY_HDR
#endif
...
#undef MY_HDR    /* Noncompliant */
</pre>
<h3>Compliant solution</h3>
<pre>
#define LEVEL(i) int const i = #i
LEVEL(Debug);
LEVEL(Warning);
LEVEL(Error);
#undef LEVEL
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2004, 19.6 - #undef shall not be used. </li>
  <li> MISRA C++:2008, 16-0-3 - #undef shall not be used. </li>
  <li> MISRA C:2012, 20.5 - #undef should not be used </li>
</ul>",CRITICAL,2h,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKHMeTlwiQl6exQHP,c:S1172,"Remove the unused parameter ""group"".",Unused function parameters should be removed,"<h2>Why is this an issue?</h2>
<p>A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s
body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to
such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing
function parameters that are not being utilized is considered best practice.</p>
<h3>Exceptions</h3>
<p>There are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is
virtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it
is only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the <code>[[maybe_unused]]</code> attribute to
be explicit about it.</p>
<pre>
void f([[maybe_unused]] int i) {
  assert(i &lt; 42); // In optimized mode, this assert will be removed, and ""i"" will be unused
}
</pre>
<p>In case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.</p>
<h2>How to fix it</h2>
<p>Having unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability
and introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void doSomething(int a, int b) { // Noncompliant, ""b"" is unused
  compute(a);
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void doSomething(int a) {
  compute(a);
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>
  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>
  <li> <a href=""https://wiki.sei.cmu.edu/confluence/x/5dUxBQ"">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed
  </li>
  <li> C++ Core Guidelines - <a
  href=""https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed"">F.9: Unused parameters
  should be unnamed</a> </li>
</ul>",MAJOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'MEDIUM'}]",[]
AZHFKHMeTlwiQl6exQHR,c:S3776,Refactor this function to reduce its Cognitive Complexity from 31 to the 25 allowed.,Cognitive Complexity of functions should not be too high,"<p>This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.</p>
<h2>Why is this an issue?</h2>
<p>Cognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard
to read, understand, test, and modify.</p>
<p>As a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.</p>
<h3>Which syntax in code does impact cognitive complexity score?</h3>
<p>Here are the core concepts:</p>
<ul>
  <li> <strong>Cognitive complexity is incremented each time the code breaks the normal linear reading flow.</strong><br> This concerns, for example,
  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators. </li>
  <li> <strong>Each nesting level increases complexity.</strong><br> During code reading, the deeper you go through nested layers, the harder it
  becomes to keep the context in mind. </li>
  <li> <strong>Method calls are free</strong><br> A well-picked method name is a summary of multiple lines of code. A reader can first explore a
  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.<br> <em>Note:</em> This does not
  apply to recursive calls, those will increment cognitive score. </li>
</ul>
<p>The method of computation is fully detailed in the pdf linked in the resources.</p>
<h3>What is the potential impact?</h3>
<p>Developers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of
maintenance.</p>
<h2>How to fix it</h2>
<p>Reducing cognitive complexity can be challenging.<br> Here are a few suggestions:</p>
<ul>
  <li> <strong>Extract complex conditions in a new function.</strong><br> Mixed operators in condition will increase complexity. Extracting the
  condition in a new function with an appropriate name will reduce cognitive load. </li>
  <li> <strong>Break down large functions.</strong><br> Large functions can be hard to understand and maintain. If a function is doing too many
  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. </li>
  <li> <strong>Avoid deep nesting by returning early.</strong><br> To avoid the nesting of conditions, process exceptional cases first and return
  early. </li>
</ul>
<h3>Code examples</h3>
<p><strong>Extraction of a complex condition in a new function.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is using a complex condition and has a cognitive cost of 3.</p>
<pre data-diff-id=""1"" data-diff-type=""noncompliant"">
void processEligibleUser(User user) {
  if ((user.isActive() &amp;&amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)
     || (user.getAge() &gt; 18)) {              // +1 (mixing operators)
    // process the user
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Even if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the
<code>processEligibleUser</code> function, which now only has a cognitive score of 1.</p>
<pre data-diff-id=""1"" data-diff-type=""compliant"">
void processEligibleUser(User user) {
  if (isEligibleUser(user)) {  // +1 (if)
    // process the user
  }
}

bool isEligibleUser(User user) {
  return (user.isActive() &amp;&amp; user.hasProfile()) // +1 (multiple conditions)
      || (user.getAge() &gt; 18));                 // +1 (mixing operators)
}
</pre>
<p><strong>Break down large functions.</strong></p>
<h4>Noncompliant code example</h4>
<p>The code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.<br> The overall complexity of
<code>processUser</code> is 8.</p>
<pre data-diff-id=""3"" data-diff-type=""noncompliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process active user with profile
    } else {                  // +1 (else)
      // process active user without profile
    }
  } else {                    // +1 (else)
    if (user.hasProfile()) {  // +1 (if) +1 (nested)
      // process inactive user with profile
    } else {                  // +1 (else)
      // process inactive user without profile
    }
  }
}
</pre>
<p>This function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer
nested.<br> The <code>processUser</code> now has a complexity score of two.</p>
<h4>Compliant solution</h4>
<pre data-diff-id=""3"" data-diff-type=""compliant"">
void processUser(User user) {
  if (user.isActive()) {      // +1 (if)
    processActiveUser(user);
  } else {                    // +1 (else)
    processInactiveUser(user);
  }
}

void processActiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
      // process active user with profile
  } else {                    // +1 (else)
      // process active user without profile
  }
}

void processInactiveUser(User user) {
  if (user.hasProfile()) {    // +1 (if)
    // process inactive user with profile
  } else {                    // +1 (else)
    // process inactive user without profile
  }
}
</pre>
<p><strong>Avoid deep nesting by returning early.</strong></p>
<h4>Noncompliant code example</h4>
<p>The below code has a cognitive complexity of 3.</p>
<pre data-diff-id=""4"" data-diff-type=""noncompliant"">
void checkUser(User user) {
  if (user.isActive()) {     // +1 (if)
    if (user.hasProfile()) { // +1 (if) +1 (nested)
      // do something
    }
  }
}
</pre>
<h4>Compliant solution</h4>
<p>Checking for the edge case first flattens the <code>if</code> statements and reduces the cognitive complexity to 2.</p>
<pre data-diff-id=""4"" data-diff-type=""compliant"">
void checkUser(User user) {
  if (!user.isActive()) {
    return;
  }
  if (!user.hasProfile()) {
    return;
  }
  // do something
}
</pre>
<h3>Pitfalls</h3>
<p>As this code is complex, ensure that you have unit tests that cover the code before refactoring.</p>
<h2>Resources</h2>
<h3>Documentation</h3>
<ul>
  <li> Sonar - <a href=""https://www.sonarsource.com/docs/CognitiveComplexity.pdf"">Cognitive Complexity</a> </li>
</ul>
<h3>Articles &amp; blog posts</h3>
<ul>
  <li> Sonar Blog - <a href=""https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/"">5 Clean Code Tips for Reducing
  Cognitive Complexity</a> </li>
</ul>",CRITICAL,5min,FOCUSED,ADAPTABLE,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'HIGH'}]",[]
AZHFKHMeTlwiQl6exQHS,c:S1301,"Replace this ""switch"" statement by ""if"" statements to increase readability.","""if"" statements should be preferred over ""switch"" when simpler","<h2>Why is this an issue?</h2>
<p><code>switch</code> statements are useful when there are many different cases depending on the value of the same expression. For just one or two
cases, however, the code will be more readable with <code>if</code> statements.</p>
<p>In particular, <code>if</code> statements are more suitable when the condition of the <code>switch</code> is boolean.</p>
<p>This rule detects statements that could be simplified with a simple <code>if / else</code>. That is when there is at most one <code>case</code>,
not counting those that fall through to a <code>default</code>.</p>
<p>The following code:</p>
<pre>
switch (variable) {
  case 0:
    doSomething();
    break;
  case 1:
  case 2:
  default:
    doSomethingElse();
    break;
}
</pre>
<p>Would be more readable that way:</p>
<pre>
if (variable == 0) {
  doSomething();
} else {
  doSomethingElse();
}
</pre>
<p>While the following snippets don’t trigger the rule because using <code>if</code> would not improve their readability:</p>
<pre>
switch (variable) {
  case 0:
  case 1: // Would need a less readable check in an `if`
    doSomething();
    break;
}

switch (variable) {
  case 0:
    doSomething();
    break;
  case 1: // Would require introducing `else if`
    doSomethingElse();
    break;
}
</pre>
<h2>Resources</h2>
<ul>
  <li> MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses </li>
</ul>",MINOR,5min,CLEAR,INTENTIONAL,"[{'softwareQuality': 'MAINTAINABILITY', 'severity': 'LOW'}]",[]
